<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.31)&#10;project(mouse_crosshair)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;&#10;add_executable(mouse_crosshair main.cpp)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.31)&#10;project(mouse_crosshair)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;&#10;add_executable(mouse_crosshair&#10;    main.cpp&#10;    crosshair.cpp&#10;    config.cpp&#10;    hotkey.cpp&#10;)&#10;&#10;target_link_libraries(mouse_crosshair&#10;    user32&#10;    gdi32&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.cpp" />
              <option name="originalContent" value="#include &quot;config.h&quot;&#10;#include &lt;windows.h&gt;&#10;&#10;bool Config::Load(const char* filename) {&#10;    // 横线&#10;    horizontal.width  = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r      = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g      = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b      = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha  = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width  = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r      = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g      = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b      = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha  = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    hotkey.mod = GetPrivateProfileIntA(&quot;Hotkey&quot;, &quot;Mod&quot;, hotkey.mod, filename);&#10;    char vkStr[8] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    if (vkStr[0]) {&#10;        if (vkStr[1] == 0 &amp;&amp; vkStr[0] &gt;= 'A' &amp;&amp; vkStr[0] &lt;= 'Z') {&#10;            hotkey.vk = vkStr[0];&#10;        } else {&#10;            hotkey.vk = static_cast&lt;int&gt;(strtol(vkStr, nullptr, 0));&#10;        }&#10;    }&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    UINT dpi = 96;&#10;    if (HMODULE hUser32 = LoadLibraryA(&quot;User32.dll&quot;)) {&#10;        typedef UINT (WINAPI *GetDpiForSystem_t)();&#10;        if (auto pGetDpiForSystem = reinterpret_cast&lt;GetDpiForSystem_t&gt;(GetProcAddress(hUser32, &quot;GetDpiForSystem&quot;))) {&#10;            dpi = pGetDpiForSystem();&#10;        } else {&#10;            const HDC hdc = GetDC(nullptr);&#10;            dpi = GetDeviceCaps(hdc, LOGPIXELSX);&#10;            ReleaseDC(nullptr, hdc);&#10;        }&#10;        FreeLibrary(hUser32);&#10;    }&#10;&#10;    const double scale = dpi / 96.0;&#10;    // 横线长度基于屏幕宽度&#10;    horizontal.length = static_cast&lt;int&gt;(screenWidth * scale);&#10;    // 竖线长度基于屏幕高度&#10;    vertical.length   = static_cast&lt;int&gt;(screenHeight * scale);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config.h&quot;&#10;#include &lt;windows.h&gt;&#10;&#10;bool Config::Load(const char* filename) {&#10;    // 横线&#10;    horizontal.width  = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r      = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g      = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b      = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha  = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width  = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r      = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g      = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b      = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha  = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    hotkey.mod = GetPrivateProfileIntA(&quot;Hotkey&quot;, &quot;Mod&quot;, hotkey.mod, filename);&#10;    char vkStr[8] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    if (vkStr[0]) {&#10;        if (vkStr[1] == 0 &amp;&amp; vkStr[0] &gt;= 'A' &amp;&amp; vkStr[0] &lt;= 'Z') {&#10;            hotkey.vk = vkStr[0];&#10;        } else {&#10;            hotkey.vk = static_cast&lt;int&gt;(strtol(vkStr, nullptr, 0));&#10;        }&#10;    }&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    UINT dpi = 96;&#10;    if (HMODULE hUser32 = LoadLibraryA(&quot;User32.dll&quot;)) {&#10;        typedef UINT (WINAPI *GetDpiForSystem_t)();&#10;        if (auto pGetDpiForSystem = reinterpret_cast&lt;GetDpiForSystem_t&gt;(GetProcAddress(hUser32, &quot;GetDpiForSystem&quot;))) {&#10;            dpi = pGetDpiForSystem();&#10;        } else {&#10;            const HDC hdc = GetDC(nullptr);&#10;            dpi = GetDeviceCaps(hdc, LOGPIXELSX);&#10;            ReleaseDC(nullptr, hdc);&#10;        }&#10;        FreeLibrary(hUser32);&#10;    }&#10;&#10;    const double scale = dpi / 96.0;&#10;    // 横线长度基于屏幕宽度&#10;    horizontal.length = static_cast&lt;int&gt;(screenWidth * scale);&#10;    // 竖线长度基于屏幕高度&#10;    vertical.length   = static_cast&lt;int&gt;(screenHeight * scale);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#define MOD_ALT 0x0001&#10;#define MOD_CONTROL 0x0002&#10;#define MOD_SHIFT 0x0004&#10;&#10;struct LineConfig {&#10;    int length = 1920;&#10;    int width = 2;&#10;    int r = 255, g = 0, b = 0;&#10;    int alpha = 128;&#10;};&#10;&#10;struct HotkeyConfig {&#10;    int mod = MOD_CONTROL | MOD_ALT;&#10;    int vk = 'H';&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char* filename);&#10;    void AutoSetLength();&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#define MOD_ALT 0x0001&#10;#define MOD_CONTROL 0x0002&#10;#define MOD_SHIFT 0x0004&#10;&#10;struct LineConfig {&#10;    int length = 1920;&#10;    int width = 2;&#10;    int r = 255, g = 0, b = 0;&#10;    int alpha = 128;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 20) width = 20;&#10;        if (r &lt; 0) r = 0;&#10;        if (r &gt; 255) r = 255;&#10;        if (g &lt; 0) g = 0;&#10;        if (g &gt; 255) g = 255;&#10;        if (b &lt; 0) b = 0;&#10;        if (b &gt; 255) b = 255;&#10;        if (alpha &lt; 0) alpha = 0;&#10;        if (alpha &gt; 255) alpha = 255;&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    int mod = MOD_CONTROL | MOD_ALT;&#10;    int vk = 'H';&#10;&#10;    void Clamp() {&#10;        // mod: 0~15（MOD_ALT|MOD_CONTROL|MOD_SHIFT|MOD_WIN）&#10;        if (mod &lt; 0) mod = 0;&#10;        if (mod &gt; 15) mod = 15;&#10;        // vk: 0~255&#10;        if (vk &lt; 0) vk = 0;&#10;        if (vk &gt; 255) vk = 255;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char* filename);&#10;    void AutoSetLength();&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey.Clamp();&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.cpp" />
              <option name="updatedContent" value="#include &quot;config_file_util.h&quot;&#10;#include &lt;windows.h&gt;&#10;#include &lt;fstream&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path() {&#10;    char exePath[MAX_PATH] = {};&#10;    GetModuleFileNameA(nullptr, exePath, MAX_PATH);&#10;    std::string path(exePath);&#10;    const size_t pos = path.find_last_of(&quot;\\/&quot;);&#10;    if (pos != std::string::npos) {&#10;        path = path.substr(0, pos + 1);&#10;    } else {&#10;        path = &quot;./&quot;;&#10;    }&#10;    return path + &quot;crosshair.ini&quot;;&#10;}&#10;&#10;// 写入默认配置内容&#10;static void write_default_config(const std::string&amp; path) {&#10;    static const char* default_ini = R&quot;(&#10;[Horizontal]&#10;Width=3&#10;R=0&#10;G=255&#10;B=0&#10;Alpha=180&#10;&#10;[Vertical]&#10;Width=2&#10;R=255&#10;G=0&#10;B=0&#10;Alpha=200&#10;&#10;[Hotkey]&#10;Mod=3&#10;VK=H&#10;)&quot;;&#10;    std::ofstream ofs(path, std::ios::out | std::ios::trunc);&#10;    ofs &lt;&lt; default_ini;&#10;    ofs.close();&#10;}&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string&amp; path) {&#10;    const DWORD attr = GetFileAttributesA(path.c_str());&#10;    if (attr == INVALID_FILE_ATTRIBUTES || (attr &amp; FILE_ATTRIBUTE_DIRECTORY)) {&#10;        write_default_config(path);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.h" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;string&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path();&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string&amp; path);&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.cpp" />
              <option name="originalContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 10&#10;#define TRANSPARENT_COLOR RGB(0,0,0)&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    // 在创建窗口前设置DPI感知&#10;    SetProcessDPIAware();&#10;&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    // 设置分层窗口属性以确保鼠标穿透&#10;    SetLayeredWindowAttributes(hwnd, TRANSPARENT_COLOR, 255, LWA_COLORKEY | LWA_ALPHA);&#10;&#10;    // 确保窗口完全透明给鼠标事件&#10;    SetWindowLongPtr(hwnd, GWL_EXSTYLE,&#10;        GetWindowLongPtr(hwnd, GWL_EXSTYLE) | WS_EX_TRANSPARENT);&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            break;&#10;        case WM_ERASEBKGND:&#10;            return 1;&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE);&#10;            }&#10;            break;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            break;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;    return 0;&#10;}&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;&#10;    Gdiplus::Graphics graphics(hdc);&#10;    graphics.SetPageUnit(Gdiplus::UnitPixel);&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        const Gdiplus::Color color(c.alpha, c.r, c.g, c.b);&#10;        const Gdiplus::Pen pen(color, static_cast&lt;Gdiplus::REAL&gt;(c.width));&#10;        graphics.DrawLine(&amp;pen,&#10;                          static_cast&lt;INT&gt;(pt.x - c.length), static_cast&lt;INT&gt;(pt.y),&#10;                          static_cast&lt;INT&gt;(pt.x + c.length), static_cast&lt;INT&gt;(pt.y)&#10;        );&#10;    }&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        const Gdiplus::Color color(c.alpha, c.r, c.g, c.b);&#10;        const Gdiplus::Pen pen(color, static_cast&lt;Gdiplus::REAL&gt;(c.width));&#10;        graphics.DrawLine(&amp;pen,&#10;                          static_cast&lt;INT&gt;(pt.x), static_cast&lt;INT&gt;(pt.y - c.length),&#10;                          static_cast&lt;INT&gt;(pt.x), static_cast&lt;INT&gt;(pt.y + c.length)&#10;        );&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 10&#10;#define TRANSPARENT_COLOR RGB(0,0,0)&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    // 在创建窗口前设置DPI感知&#10;    SetProcessDPIAware();&#10;&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    // 设置分层窗口属性以确保鼠标穿透&#10;    SetLayeredWindowAttributes(hwnd, TRANSPARENT_COLOR, 255, LWA_COLORKEY | LWA_ALPHA);&#10;&#10;    // 确保窗口完全透明给鼠标事件&#10;    SetWindowLongPtr(hwnd, GWL_EXSTYLE,&#10;        GetWindowLongPtr(hwnd, GWL_EXSTYLE) | WS_EX_TRANSPARENT);&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            break;&#10;        case WM_ERASEBKGND:&#10;            return 1;&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE);&#10;            }&#10;            break;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            break;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;    return 0;&#10;}&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;&#10;    Gdiplus::Graphics graphics(hdc);&#10;    graphics.SetPageUnit(Gdiplus::UnitPixel);&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        const Gdiplus::Color color(c.alpha, c.r, c.g, c.b);&#10;        Gdiplus::Pen pen(color, static_cast&lt;Gdiplus::REAL&gt;(c.width));&#10;        // 注意：GDI+的DrawLine包含起点但不包含终点，所以+1&#10;        graphics.DrawLine(&amp;pen,&#10;                          static_cast&lt;INT&gt;(pt.x - c.length), static_cast&lt;INT&gt;(pt.y),&#10;                          static_cast&lt;INT&gt;(pt.x + c.length + 1), static_cast&lt;INT&gt;(pt.y)&#10;        );&#10;    }&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        const Gdiplus::Color color(c.alpha, c.r, c.g, c.b);&#10;        Gdiplus::Pen pen(color, static_cast&lt;Gdiplus::REAL&gt;(c.width));&#10;        graphics.DrawLine(&amp;pen,&#10;                          static_cast&lt;INT&gt;(pt.x), static_cast&lt;INT&gt;(pt.y - c.length),&#10;                          static_cast&lt;INT&gt;(pt.x), static_cast&lt;INT&gt;(pt.y + c.length + 1)&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config&amp; cfg);&#10;    bool Create();&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;    void DrawCrosshair(HDC hdc);&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;&#10;    // Added members to separately store horizontal and vertical line configurations&#10;    int horizontalLineThickness;&#10;    int verticalLineThickness;&#10;    COLORREF horizontalLineColor;&#10;    COLORREF verticalLineColor;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config&amp; cfg);&#10;    bool Create();&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;    void DrawCrosshair(HDC hdc);&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.ini">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.ini" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="[Horizontal]&#10;Length=60&#10;Width=3&#10;R=0&#10;G=255&#10;B=0&#10;Alpha=180&#10;&#10;[Vertical]&#10;Length=80&#10;Width=2&#10;R=255&#10;G=0&#10;B=0&#10;Alpha=200&#10;&#10;[Hotkey]&#10;; Mod为修饰键位掩码，见WinAPI RegisterHotKey文档&#10;; 1=Alt, 2=Ctrl, 4=Shift, 8=Win，可组合&#10;Mod=3&#10;; VK可为单字母（如H），或虚拟键码（如0x70为F1）&#10;VK=H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.cpp" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#include &quot;hotkey.h&quot;&#10;&#10;#define HOTKEY_ID 0x1234&#10;&#10;void HotkeyManager::RegisterToggleHotkey(const HotkeyConfig&amp; cfg) {&#10;    RegisterHotKey(nullptr, HOTKEY_ID, cfg.mod, cfg.vk);&#10;}&#10;&#10;bool HotkeyManager::IsToggleHotkey(const MSG&amp; msg) {&#10;    return msg.message == WM_HOTKEY &amp;&amp; msg.wParam == HOTKEY_ID;&#10;}&#10;&#10;void HotkeyManager::UnregisterAll() {&#10;    UnregisterHotKey(nullptr, HOTKEY_ID);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.h" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class HotkeyManager {&#10;public:&#10;    void RegisterToggleHotkey(const HotkeyConfig&amp; cfg);&#10;    bool IsToggleHotkey(const MSG&amp; msg);&#10;    void UnregisterAll();&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.cpp" />
              <option name="originalContent" value="#include &lt;windows.h&gt;&#10;#include &lt;fstream&gt;&#10;#include &lt;string&gt;&#10;#include &quot;crosshair.h&quot;&#10;#include &quot;config.h&quot;&#10;#include &quot;hotkey.h&quot;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path() {&#10;    char exePath[MAX_PATH] = {};&#10;    GetModuleFileNameA(nullptr, exePath, MAX_PATH);&#10;    std::string path(exePath);&#10;    const size_t pos = path.find_last_of(&quot;\\/&quot;);&#10;    if (pos != std::string::npos) {&#10;        path = path.substr(0, pos + 1);&#10;    } else {&#10;        path = &quot;./&quot;;&#10;    }&#10;    return path + &quot;crosshair.ini&quot;;&#10;}&#10;&#10;// 写入默认配置内容&#10;void write_default_config(const std::string&amp; path) {&#10;    static const char* default_ini = R&quot;(&#10;[Horizontal]&#10;Width=3&#10;R=0&#10;G=255&#10;B=0&#10;Alpha=180&#10;&#10;[Vertical]&#10;Width=2&#10;R=255&#10;G=0&#10;B=0&#10;Alpha=200&#10;&#10;[Hotkey]&#10;Mod=3&#10;VK=H&#10;)&quot;;&#10;    std::ofstream ofs(path, std::ios::out | std::ios::trunc);&#10;    ofs &lt;&lt; default_ini;&#10;    ofs.close();&#10;}&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string&amp; path) {&#10;    const DWORD attr = GetFileAttributesA(path.c_str());&#10;    if (attr == INVALID_FILE_ATTRIBUTES || (attr &amp; FILE_ATTRIBUTE_DIRECTORY)) {&#10;        write_default_config(path);&#10;    }&#10;}&#10;&#10;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int) {&#10;    std::string configPath = get_config_path();&#10;    ensure_config_exists(configPath);&#10;&#10;    Config config;&#10;    if (!config.Load(configPath.c_str())) {&#10;        MessageBoxA(nullptr, &quot;Error load config, use default values.&quot;, &quot;Warning&quot;, MB_OK | MB_ICONINFORMATION);&#10;    }&#10;    config.AutoSetLength();&#10;&#10;    CrosshairWindow crosshair(hInstance, config);&#10;    if (!crosshair.Create()) {&#10;        MessageBoxA(nullptr, &quot;Error creating Corsshair window.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        return 1;&#10;    }&#10;&#10;    HotkeyManager hotkey;&#10;    hotkey.RegisterToggleHotkey(config.hotkey);&#10;&#10;    MSG msg;&#10;    while (GetMessage(&amp;msg, nullptr, 0, 0)) {&#10;        if (hotkey.IsToggleHotkey(msg)) {&#10;            crosshair.ToggleVisible();&#10;            continue;&#10;        }&#10;        TranslateMessage(&amp;msg);&#10;        DispatchMessage(&amp;msg);&#10;    }&#10;&#10;    hotkey.UnregisterAll();&#10;    return 0;&#10;}" />
              <option name="updatedContent" value="#include &lt;windows.h&gt;&#10;#include &lt;string&gt;&#10;#include &quot;crosshair.h&quot;&#10;#include &quot;config.h&quot;&#10;#include &quot;hotkey.h&quot;&#10;#include &quot;config_file_util.h&quot;&#10;&#10;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int) {&#10;    std::string configPath = get_config_path();&#10;    ensure_config_exists(configPath);&#10;&#10;    Config config;&#10;    if (!config.Load(configPath.c_str())) {&#10;        MessageBoxA(nullptr, &quot;Error load config, use default values.&quot;, &quot;Warning&quot;, MB_OK | MB_ICONINFORMATION);&#10;    }&#10;    config.AutoSetLength();&#10;&#10;    CrosshairWindow crosshair(hInstance, config);&#10;    if (!crosshair.Create()) {&#10;        MessageBoxA(nullptr, &quot;Error creating Corsshair window.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        return 1;&#10;    }&#10;&#10;    HotkeyManager hotkey;&#10;    hotkey.RegisterToggleHotkey(config.hotkey);&#10;&#10;    MSG msg;&#10;    while (GetMessage(&amp;msg, nullptr, 0, 0)) {&#10;        if (hotkey.IsToggleHotkey(msg)) {&#10;            crosshair.ToggleVisible();&#10;            continue;&#10;        }&#10;        TranslateMessage(&amp;msg);&#10;        DispatchMessage(&amp;msg);&#10;    }&#10;&#10;    hotkey.UnregisterAll();&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>