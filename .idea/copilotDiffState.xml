<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.cpp" />
              <option name="originalContent" value="#include &quot;config.h&quot;&#10;&#10;bool Config::Load(const char *filename) {&#10;    // 横线&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey.mod |= MOD_SHIFT;&#10;    if (hotkey.mod &lt; 1 || hotkey.mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) hotkey.mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey.vk = ParseVK(vkStr);&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    UINT dpi = 96;&#10;    if (const HMODULE hUser32 = LoadLibraryA(&quot;User32.dll&quot;)) {&#10;        typedef UINT (WINAPI *GetDpiForSystem_t)();&#10;        if (const auto pGetDpiForSystem = reinterpret_cast&lt;GetDpiForSystem_t&gt;(GetProcAddress(hUser32, &quot;GetDpiForSystem&quot;))) {&#10;            dpi = pGetDpiForSystem();&#10;        } else {&#10;            const HDC hdc = GetDC(nullptr);&#10;            dpi = GetDeviceCaps(hdc, LOGPIXELSX);&#10;            ReleaseDC(nullptr, hdc);&#10;        }&#10;        FreeLibrary(hUser32);&#10;    }&#10;&#10;    const double scale = dpi / 96.0;&#10;    // 横线长度基于屏幕宽度&#10;    horizontal.length = static_cast&lt;int&gt;(screenWidth * scale);&#10;    // 竖线长度基于屏幕高度&#10;    vertical.length = static_cast&lt;int&gt;(screenHeight * scale);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config.h&quot;&#10;&#10;bool Config::Load(const char *filename) {&#10;    // 横线&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey.mod |= MOD_SHIFT;&#10;    if (hotkey.mod &lt; 1 || hotkey.mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) hotkey.mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey.vk = ParseVK(vkStr);&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    // 简化 DPI 获取逻辑，直接使用屏幕尺寸&#10;    horizontal.length = screenWidth;&#10;    vertical.length = screenHeight;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;struct LineConfig {&#10;    unsigned int length = 2222;&#10;    unsigned int width = 21;&#10;    unsigned int r = 233, g = 233, b = 233;&#10;    unsigned int alpha = 199;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;&#10;    unsigned int vk = VK_H;&#10;&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char *filename);&#10;&#10;    void AutoSetLength();&#10;&#10;    static int ParseVK(const char *str) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        // ReSharper disable once CppUseRangeAlgorithm&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.starts_with(&quot;vk_&quot;)) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        return VK_H;&#10;    }&#10;&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey.Clamp();&#10;    }&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;struct LineConfig {&#10;    unsigned int length = 2222;&#10;    unsigned int width = 21;&#10;    unsigned int r = 233, g = 233, b = 233;&#10;    unsigned int alpha = 199;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;&#10;    unsigned int vk = VK_H;&#10;&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char *filename);&#10;&#10;    void AutoSetLength();&#10;&#10;    static int ParseVK(const char *str) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.length() &gt; 3 &amp;&amp; key.substr(0, 3) == &quot;vk_&quot;) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        return VK_H;&#10;    }&#10;&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey.Clamp();&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.cpp" />
              <option name="originalContent" value="#include &quot;config_file_util.h&quot;&#10;#include &lt;windows.h&gt;&#10;#include &lt;fstream&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path() {&#10;    char exePath[MAX_PATH] = {};&#10;    GetModuleFileNameA(nullptr, exePath, MAX_PATH);&#10;    std::string path(exePath);&#10;    if (const size_t pos = path.find_last_of(&quot;\\/&quot;); pos != std::string::npos) {&#10;        path = path.substr(0, pos + 1);&#10;    } else {&#10;        path = &quot;./&quot;;&#10;    }&#10;    return path + &quot;crosshair.ini&quot;;&#10;}&#10;&#10;// 写入默认配置内容&#10;static void write_default_config(const std::string &amp;path) {&#10;    std::ofstream ofs(path, std::ios::out | std::ios::trunc);&#10;    ofs &lt;&lt; DEFAULT_INI;&#10;    ofs.close();&#10;}&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string &amp;path) {&#10;    const DWORD attr = GetFileAttributesA(path.c_str());&#10;    if (attr == INVALID_FILE_ATTRIBUTES || attr &amp; FILE_ATTRIBUTE_DIRECTORY) {&#10;        write_default_config(path);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config_file_util.h&quot;&#13;&#10;#include &lt;windows.h&gt;&#13;&#10;#include &lt;fstream&gt;&#13;&#10;&#13;&#10;// 获取配置文件绝对路径（与exe同目录）&#13;&#10;std::string get_config_path() {&#13;&#10;    char path[MAX_PATH];&#13;&#10;    GetModuleFileNameA(nullptr, path, MAX_PATH);&#13;&#10;    std::string exePath = path;&#13;&#10;    size_t pos = exePath.find_last_of(&quot;\\/&quot;);&#13;&#10;    if (pos != std::string::npos) {&#13;&#10;        exePath = exePath.substr(0, pos + 1);&#13;&#10;    }&#13;&#10;    return exePath + &quot;config.ini&quot;;&#13;&#10;}&#13;&#10;&#13;&#10;// 如果配置文件不存在则创建&#13;&#10;void ensure_config_exists(const std::string &amp;path) {&#13;&#10;    std::ifstream file(path);&#13;&#10;    if (!file.good()) {&#13;&#10;        std::ofstream outFile(path);&#13;&#10;        if (outFile.is_open()) {&#13;&#10;            outFile &lt;&lt; DEFAULT_INI;&#13;&#10;            outFile.close();&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.h" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;string&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path();&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string&amp; path);&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.cpp" />
              <option name="originalContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 16&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 使用FALSE避免背景擦除&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha的DIB&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int left = std::max(0, pt.x - halfLength);&#10;        int right = std::min(width, pt.x + halfLength);&#10;&#10;        if (left &lt; right) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(left),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;                static_cast&lt;Gdiplus::REAL&gt;(right),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;            );&#10;        }&#10;    }&#10;&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int top = std::max(0, pt.y - halfLength);&#10;        int bottom = std::min(height, pt.y + halfLength);&#10;&#10;        if (top &lt; bottom) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(top),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(bottom)&#10;            );&#10;        }&#10;    }&#10;&#10;    POINT ptSrc = { 0, 0 };&#10;    SIZE sizeWnd = { width, height };&#10;    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#include &lt;algorithm&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 16&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 使用FALSE避免背景擦除&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha的DIB&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int left = std::max(0, pt.x - halfLength);&#10;        int right = std::min(width, pt.x + halfLength);&#10;&#10;        if (left &lt; right) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(left),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;                static_cast&lt;Gdiplus::REAL&gt;(right),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;            );&#10;        }&#10;    }&#10;&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int top = std::max(0, pt.y - halfLength);&#10;        int bottom = std::min(height, pt.y + halfLength);&#10;&#10;        if (top &lt; bottom) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(top),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(bottom)&#10;            );&#10;        }&#10;    }&#10;&#10;    POINT ptSrc = { 0, 0 };&#10;    SIZE sizeWnd = { width, height };&#10;    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;    ~CrosshairWindow();&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.ini">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.ini" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="[Horizontal]&#10;Length=60&#10;Width=3&#10;R=0&#10;G=255&#10;B=0&#10;Alpha=180&#10;&#10;[Vertical]&#10;Length=80&#10;Width=2&#10;R=255&#10;G=0&#10;B=0&#10;Alpha=200&#10;&#10;[Hotkey]&#10;; Mod为修饰键位掩码，见WinAPI RegisterHotKey文档&#10;; 1=Alt, 2=Ctrl, 4=Shift, 8=Win，可组合&#10;Mod=3&#10;; VK可为单字母（如H），或虚拟键码（如0x70为F1）&#10;VK=H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.cpp" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#include &quot;hotkey.h&quot;&#10;&#10;#define HOTKEY_ID 0x1234&#10;&#10;void HotkeyManager::RegisterToggleHotkey(const HotkeyConfig&amp; cfg) {&#10;    RegisterHotKey(nullptr, HOTKEY_ID, cfg.mod, cfg.vk);&#10;}&#10;&#10;bool HotkeyManager::IsToggleHotkey(const MSG&amp; msg) {&#10;    return msg.message == WM_HOTKEY &amp;&amp; msg.wParam == HOTKEY_ID;&#10;}&#10;&#10;void HotkeyManager::UnregisterAll() {&#10;    UnregisterHotKey(nullptr, HOTKEY_ID);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.h" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class HotkeyManager {&#10;public:&#10;    void RegisterToggleHotkey(const HotkeyConfig&amp; cfg);&#10;    bool IsToggleHotkey(const MSG&amp; msg);&#10;    void UnregisterAll();&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config.cpp" />
              <option name="originalContent" value="#include &quot;config.h&quot;&#10;&#10;// 从 INI 文件加载配置&#10;bool Config::Load(const char *filename) {&#10;    // 加载横线配置&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 加载竖线配置&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 加载显示/隐藏热键配置&#10;    char hide_modStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, hide_modStr, sizeof(hide_modStr), filename);&#10;    hotkey_h_s.mod = ParseMod(hide_modStr);&#10;&#10;    char hide_vkStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, hide_vkStr, sizeof(hide_vkStr), filename);&#10;    hotkey_h_s.vk = ParseVK(hide_vkStr, 'h');&#10;&#10;    // 加载退出热键配置&#10;    char exit_modStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, exit_modStr, sizeof(exit_modStr), filename);&#10;    hotkey_exit.mod = ParseMod(exit_modStr);&#10;&#10;    char exit_vkStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, exit_vkStr, sizeof(exit_vkStr), filename);&#10;    hotkey_exit.vk = ParseVK(exit_vkStr, 'e');&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;// 根据屏幕尺寸自动设置十字准星长度&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    // 设置为全屏幕宽度和高度&#10;    horizontal.length = screenWidth;&#10;    vertical.length = screenHeight;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config.h&quot;&#10;&#10;// 从 INI 文件加载配置&#10;bool Config::Load(const char *filename) {&#10;    // 加载横线配置&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 加载竖线配置&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 加载显示/隐藏热键配置&#10;    char hide_modStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, hide_modStr, sizeof(hide_modStr), filename);&#10;    hotkey_h_s.mod = ParseMod(hide_modStr);&#10;&#10;    char hide_vkStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, hide_vkStr, sizeof(hide_vkStr), filename);&#10;    hotkey_h_s.vk = ParseVK(hide_vkStr, 'h');&#10;&#10;    // 加载退出热键配置&#10;    char exit_modStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, exit_modStr, sizeof(exit_modStr), filename);&#10;    hotkey_exit.mod = ParseMod(exit_modStr);&#10;&#10;    char exit_vkStr[32] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, exit_vkStr, sizeof(exit_vkStr), filename);&#10;    hotkey_exit.vk = ParseVK(exit_vkStr, 'e');&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;// 根据屏幕尺寸自动设置十字准星长度&#10;void Config::AutoSetLength() {&#10;    // 获取虚拟屏幕尺寸（包含所有监视器）&#10;    const int screenWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);&#10;&#10;    // 设置为虚拟屏幕宽度和高度，确保在多屏环境下正常工作&#10;    horizontal.length = screenWidth;&#10;    vertical.length = screenHeight;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/crosshair.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/crosshair.cpp" />
              <option name="originalContent" value="#include &quot;./crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;thread&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;constexpr int INTERVAL_mSEC = 40; // 鼠标移动事件间隔，单位毫秒&#10;&#10;HHOOK CrosshairWindow::g_mouseHook = nullptr;&#10;CrosshairWindow *CrosshairWindow::g_instance = nullptr;&#10;&#10;CrosshairWindow::CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), config(cfg), visible(true), monitorsChanged(false) {&#10;    g_instance = this;&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    DestroyMonitorWindows();&#10;    if (g_mouseHook) UnhookWindowsHookEx(g_mouseHook);&#10;    g_instance = nullptr;&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    // 枚举所有屏幕&#10;    UpdateMonitors();&#10;&#10;    // 为每个屏幕创建窗口&#10;    for (auto &amp;monitor: monitors) {&#10;        CreateWindowForMonitor(monitor);&#10;    }&#10;&#10;    // 安装全局鼠标钩子&#10;    g_mouseHook = SetWindowsHookEx(WH_MOUSE_LL, MouseProc, nullptr, 0);&#10;&#10;    return !monitors.empty();&#10;}&#10;&#10;void CrosshairWindow::UpdateMonitors() {&#10;    // 清理旧的监视器信息&#10;    DestroyMonitorWindows();&#10;    monitors.clear();&#10;&#10;    // 枚举所有监视器&#10;    EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc, reinterpret_cast&lt;LPARAM&gt;(this));&#10;}&#10;&#10;BOOL CALLBACK CrosshairWindow::MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {&#10;    auto *self = reinterpret_cast&lt;CrosshairWindow *&gt;(dwData);&#10;&#10;    MonitorInfo info = {};&#10;    info.hMonitor = hMonitor;&#10;    info.rect = *lprcMonitor;&#10;    info.hwnd = nullptr;&#10;    info.memDC = nullptr;&#10;    info.hBmp = nullptr;&#10;    info.needsUpdate = true;&#10;&#10;    self-&gt;monitors.push_back(info);&#10;    return TRUE;&#10;}&#10;&#10;void CrosshairWindow::CreateWindowForMonitor(MonitorInfo &amp;monitor) {&#10;    const int width = monitor.rect.right - monitor.rect.left;&#10;    const int height = monitor.rect.bottom - monitor.rect.top;&#10;&#10;    monitor.hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        monitor.rect.left, monitor.rect.top, width, height,&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (monitor.hwnd) {&#10;        ShowWindow(monitor.hwnd, visible ? SW_SHOW : SW_HIDE);&#10;        OnResize(monitor);&#10;    }&#10;}&#10;&#10;void CrosshairWindow::DestroyMonitorWindows() {&#10;    for (auto &amp;monitor: monitors) {&#10;        if (monitor.hwnd) {&#10;            DestroyWindow(monitor.hwnd);&#10;            monitor.hwnd = nullptr;&#10;        }&#10;        if (monitor.memDC) {&#10;            DeleteDC(monitor.memDC);&#10;            monitor.memDC = nullptr;&#10;        }&#10;        if (monitor.hBmp) {&#10;            DeleteObject(monitor.hBmp);&#10;            monitor.hBmp = nullptr;&#10;        }&#10;    }&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    for (const auto &amp;monitor: monitors) {&#10;        if (monitor.hwnd) {&#10;            ShowWindow(monitor.hwnd, visible ? SW_SHOW : SW_HIDE);&#10;        }&#10;    }&#10;}&#10;&#10;void CrosshairWindow::OnResize(MonitorInfo &amp;monitor) {&#10;    const int width = monitor.rect.right - monitor.rect.left;&#10;    const int height = monitor.rect.bottom - monitor.rect.top;&#10;&#10;    if (monitor.memDC) {&#10;        DeleteDC(monitor.memDC);&#10;        monitor.memDC = nullptr;&#10;    }&#10;    if (monitor.hBmp) {&#10;        DeleteObject(monitor.hBmp);&#10;        monitor.hBmp = nullptr;&#10;    }&#10;&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height;&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    const HDC screenDC = GetDC(nullptr);&#10;    monitor.hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    monitor.memDC = CreateCompatibleDC(screenDC);&#10;    SelectObject(monitor.memDC, monitor.hBmp);&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;&#10;MonitorInfo *CrosshairWindow::FindMonitorContainingPoint(POINT pt) {&#10;    for (auto &amp;monitor: monitors) {&#10;        if (pt.x &gt;= monitor.rect.left &amp;&amp; pt.x &lt; monitor.rect.right &amp;&amp;&#10;            pt.y &gt;= monitor.rect.top &amp;&amp; pt.y &lt; monitor.rect.bottom) {&#10;            return &amp;monitor;&#10;        }&#10;    }&#10;    return nullptr;&#10;}&#10;&#10;void CrosshairWindow::OnMouseMove() const {&#10;    if (!visible) return;&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;&#10;    // 检查屏幕配置是否发生变化&#10;    static DWORD lastMonitorCheck = 0;&#10;    DWORD currentTime = GetTickCount();&#10;    if (currentTime - lastMonitorCheck &gt; 1000) {&#10;        // 每秒检查一次&#10;        lastMonitorCheck = currentTime;&#10;        DWORD currentMonitorCount = GetSystemMetrics(SM_CMONITORS);&#10;        if (currentMonitorCount != monitors.size()) {&#10;            const_cast&lt;CrosshairWindow *&gt;(this)-&gt;UpdateMonitors();&#10;            for (auto &amp;monitor: const_cast&lt;CrosshairWindow *&gt;(this)-&gt;monitors) {&#10;                const_cast&lt;CrosshairWindow *&gt;(this)-&gt;CreateWindowForMonitor(monitor);&#10;            }&#10;        }&#10;    }&#10;&#10;    // 找到包含鼠标的屏幕并更新&#10;    for (const auto &amp;monitor: monitors) {&#10;        if (monitor.hwnd &amp;&amp; pt.x &gt;= monitor.rect.left &amp;&amp; pt.x &lt; monitor.rect.right &amp;&amp;&#10;            pt.y &gt;= monitor.rect.top &amp;&amp; pt.y &lt; monitor.rect.bottom) {&#10;            InvalidateRect(monitor.hwnd, nullptr, FALSE);&#10;        }&#10;    }&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow * self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                BeginPaint(hWnd, &amp;ps);&#10;&#10;                // 找到对应的监视器&#10;                for (auto &amp;monitor: self-&gt;monitors) {&#10;                    if (monitor.hwnd == hWnd &amp;&amp; monitor.memDC) {&#10;                        self-&gt;DrawCrosshair(monitor.memDC, monitor.rect);&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1;&#10;        case WM_SIZE:&#10;            if (self) {&#10;                // 找到对应的监视器并调整大小&#10;                for (auto &amp;monitor: self-&gt;monitors) {&#10;                    if (monitor.hwnd == hWnd) {&#10;                        CrosshairWindow::OnResize(monitor);&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;            return 0;&#10;        case WM_CLOSE:&#10;        case WM_QUIT:&#10;        case WM_NCDESTROY:&#10;        case WM_DESTROY:&#10;            if (g_mouseHook) {&#10;                UnhookWindowsHookEx(g_mouseHook);&#10;                g_mouseHook = nullptr;&#10;            }&#10;            exit(0);&#10;            break;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;void CrosshairWindow::DrawCrosshair(HDC hdc, const RECT &amp;monitorRect) const {&#10;    const int width = monitorRect.right - monitorRect.left;&#10;    const int height = monitorRect.bottom - monitorRect.top;&#10;&#10;    // 使用 GDI+ 进行抗锯齿绘制&#10;    Gdiplus::Graphics graphics(hdc);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;&#10;    // 将屏幕坐标转换为当前监视器的相对坐标&#10;    pt.x -= monitorRect.left;&#10;    pt.y -= monitorRect.top;&#10;&#10;    // 确保鼠标在当前监视器范围内&#10;    if (pt.x &lt; 0 || pt.x &gt;= width || pt.y &lt; 0 || pt.y &gt;= height) {&#10;        return;&#10;    }&#10;&#10;    // 水平线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen const pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;        const int leftLength = std::min&lt;int&gt;(pt.x, width);&#10;        const int rightLength = std::min&lt;int&gt;(width - pt.x, width);&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x - leftLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x + rightLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;        );&#10;    }&#10;    // 垂直线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen const pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;        const int topLength = std::min&lt;int&gt;(pt.y, height);&#10;        const int bottomLength = std::min&lt;int&gt;(height - pt.y, height);&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y - topLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y + bottomLength)&#10;        );&#10;    }&#10;&#10;    // 更新分层窗口&#10;    const HDC screenDC = GetDC(nullptr);&#10;    POINT ptSrc = {0, 0};&#10;    SIZE sizeWnd = {width, height};&#10;    BLENDFUNCTION blend = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};&#10;&#10;    // 找到对应的窗口句柄&#10;    HWND targetHwnd = nullptr;&#10;    for (const auto &amp;monitor: monitors) {&#10;        if (monitor.memDC == hdc) {&#10;            targetHwnd = monitor.hwnd;&#10;            break;&#10;        }&#10;    }&#10;&#10;    if (targetHwnd) {&#10;        UpdateLayeredWindow(targetHwnd, screenDC, nullptr, &amp;sizeWnd, hdc, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;    }&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;&#10;// 全局鼠标钩子回调&#10;LRESULT CALLBACK CrosshairWindow::MouseProc(const int nCode, const WPARAM wParam, const LPARAM lParam) {&#10;    static auto last = std::chrono::steady_clock::now();&#10;    if (nCode == HC_ACTION &amp;&amp; wParam == WM_MOUSEMOVE &amp;&amp; g_instance) {&#10;        const auto now = std::chrono::steady_clock::now();&#10;        const auto diff = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - last).count();&#10;        if (diff &gt;= INTERVAL_mSEC) {&#10;            last = now;&#10;            g_instance-&gt;OnMouseMove();&#10;        }&#10;    }&#10;    return CallNextHookEx(g_mouseHook, nCode, wParam, lParam);&#10;}" />
              <option name="updatedContent" value="#include &quot;./crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;thread&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;constexpr int INTERVAL_mSEC = 40; // 鼠标移动事件间隔，单位毫秒&#10;&#10;HHOOK CrosshairWindow::g_mouseHook = nullptr;&#10;CrosshairWindow *CrosshairWindow::g_instance = nullptr;&#10;&#10;CrosshairWindow::CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), config(cfg), visible(true), monitorsChanged(false), &#10;      lastMousePos{0, 0}, lastMousePosValid(false) {&#10;    g_instance = this;&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    DestroyMonitorWindows();&#10;    if (g_mouseHook) UnhookWindowsHookEx(g_mouseHook);&#10;    g_instance = nullptr;&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    // 枚举所有屏幕&#10;    UpdateMonitors();&#10;&#10;    // 为每个屏幕创建窗口&#10;    for (auto &amp;monitor: monitors) {&#10;        CreateWindowForMonitor(monitor);&#10;    }&#10;&#10;    // 安装全局鼠标钩子&#10;    g_mouseHook = SetWindowsHookEx(WH_MOUSE_LL, MouseProc, nullptr, 0);&#10;&#10;    return !monitors.empty();&#10;}&#10;&#10;void CrosshairWindow::UpdateMonitors() {&#10;    // 清理旧的监视器信息&#10;    DestroyMonitorWindows();&#10;    monitors.clear();&#10;&#10;    // 枚举所有监视器&#10;    EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc, reinterpret_cast&lt;LPARAM&gt;(this));&#10;}&#10;&#10;BOOL CALLBACK CrosshairWindow::MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {&#10;    auto* self = reinterpret_cast&lt;CrosshairWindow*&gt;(dwData);&#10;&#10;    MonitorInfo info = {};&#10;    info.hMonitor = hMonitor;&#10;    info.rect = *lprcMonitor;&#10;    info.hwnd = nullptr;&#10;    info.memDC = nullptr;&#10;    info.hBmp = nullptr;&#10;    info.needsUpdate = true;&#10;    info.hasMouseCursor = false; // 初始化新字段&#10;&#10;    self-&gt;monitors.push_back(info);&#10;    return TRUE;&#10;}&#10;&#10;void CrosshairWindow::CreateWindowForMonitor(MonitorInfo &amp;monitor) {&#10;    const int width = monitor.rect.right - monitor.rect.left;&#10;    const int height = monitor.rect.bottom - monitor.rect.top;&#10;&#10;    monitor.hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        monitor.rect.left, monitor.rect.top, width, height,&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (monitor.hwnd) {&#10;        ShowWindow(monitor.hwnd, visible ? SW_SHOW : SW_HIDE);&#10;        OnResize(monitor);&#10;    }&#10;}&#10;&#10;void CrosshairWindow::DestroyMonitorWindows() {&#10;    for (auto &amp;monitor: monitors) {&#10;        if (monitor.hwnd) {&#10;            DestroyWindow(monitor.hwnd);&#10;            monitor.hwnd = nullptr;&#10;        }&#10;        if (monitor.memDC) {&#10;            DeleteDC(monitor.memDC);&#10;            monitor.memDC = nullptr;&#10;        }&#10;        if (monitor.hBmp) {&#10;            DeleteObject(monitor.hBmp);&#10;            monitor.hBmp = nullptr;&#10;        }&#10;    }&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    for (const auto &amp;monitor: monitors) {&#10;        if (monitor.hwnd) {&#10;            ShowWindow(monitor.hwnd, visible ? SW_SHOW : SW_HIDE);&#10;        }&#10;    }&#10;}&#10;&#10;void CrosshairWindow::OnResize(MonitorInfo &amp;monitor) {&#10;    const int width = monitor.rect.right - monitor.rect.left;&#10;    const int height = monitor.rect.bottom - monitor.rect.top;&#10;&#10;    if (monitor.memDC) {&#10;        DeleteDC(monitor.memDC);&#10;        monitor.memDC = nullptr;&#10;    }&#10;    if (monitor.hBmp) {&#10;        DeleteObject(monitor.hBmp);&#10;        monitor.hBmp = nullptr;&#10;    }&#10;&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height;&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    const HDC screenDC = GetDC(nullptr);&#10;    monitor.hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    monitor.memDC = CreateCompatibleDC(screenDC);&#10;    SelectObject(monitor.memDC, monitor.hBmp);&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;&#10;MonitorInfo *CrosshairWindow::FindMonitorContainingPoint(POINT pt) {&#10;    for (auto &amp;monitor: monitors) {&#10;        if (pt.x &gt;= monitor.rect.left &amp;&amp; pt.x &lt; monitor.rect.right &amp;&amp;&#10;            pt.y &gt;= monitor.rect.top &amp;&amp; pt.y &lt; monitor.rect.bottom) {&#10;            return &amp;monitor;&#10;        }&#10;    }&#10;    return nullptr;&#10;}&#10;&#10;void CrosshairWindow::OnMouseMove() const {&#10;    if (!visible) return;&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;&#10;    // 检查屏幕配置是否发生变化&#10;    static DWORD lastMonitorCheck = 0;&#10;    DWORD currentTime = GetTickCount();&#10;    if (currentTime - lastMonitorCheck &gt; 1000) { // 每秒检查一次&#10;        lastMonitorCheck = currentTime;&#10;        DWORD currentMonitorCount = GetSystemMetrics(SM_CMONITORS);&#10;        if (currentMonitorCount != monitors.size()) {&#10;            const_cast&lt;CrosshairWindow*&gt;(this)-&gt;UpdateMonitors();&#10;            for (auto&amp; monitor : const_cast&lt;CrosshairWindow*&gt;(this)-&gt;monitors) {&#10;                const_cast&lt;CrosshairWindow*&gt;(this)-&gt;CreateWindowForMonitor(monitor);&#10;            }&#10;        }&#10;    }&#10;&#10;    // 找到当前鼠标所在的屏幕&#10;    MonitorInfo* currentMonitor = nullptr;&#10;    for (auto&amp; monitor : const_cast&lt;CrosshairWindow*&gt;(this)-&gt;monitors) {&#10;        if (pt.x &gt;= monitor.rect.left &amp;&amp; pt.x &lt; monitor.rect.right &amp;&amp;&#10;            pt.y &gt;= monitor.rect.top &amp;&amp; pt.y &lt; monitor.rect.bottom) {&#10;            currentMonitor = &amp;monitor;&#10;            break;&#10;        }&#10;    }&#10;&#10;    // 如果有有效的上一次位置，检查是否需要清除之前的屏幕&#10;    if (lastMousePosValid) {&#10;        MonitorInfo* lastMonitor = const_cast&lt;CrosshairWindow*&gt;(this)-&gt;FindMonitorContainingPoint(lastMousePos);&#10;        &#10;        // 清除所有屏幕的鼠标标记&#10;        for (auto&amp; monitor : const_cast&lt;CrosshairWindow*&gt;(this)-&gt;monitors) {&#10;            if (monitor.hasMouseCursor &amp;&amp; &amp;monitor != currentMonitor) {&#10;                monitor.hasMouseCursor = false;&#10;                ClearMonitor(monitor);&#10;            }&#10;        }&#10;    }&#10;&#10;    // 更新当前屏幕&#10;    if (currentMonitor &amp;&amp; currentMonitor-&gt;hwnd) {&#10;        currentMonitor-&gt;hasMouseCursor = true;&#10;        InvalidateRect(currentMonitor-&gt;hwnd, nullptr, FALSE);&#10;    }&#10;&#10;    // 记录当前鼠标位置&#10;    lastMousePos = pt;&#10;    lastMousePosValid = true;&#10;}&#10;&#10;void CrosshairWindow::ClearMonitor(MonitorInfo &amp;monitor) const {&#10;    if (!monitor.hwnd || !monitor.memDC) return;&#10;&#10;    const int width = monitor.rect.right - monitor.rect.left;&#10;    const int height = monitor.rect.bottom - monitor.rect.top;&#10;&#10;    // 清除内存DC内容&#10;    Gdiplus::Graphics graphics(monitor.memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;&#10;    // 更新分层窗口（完全透明）&#10;    const HDC screenDC = GetDC(nullptr);&#10;    POINT ptSrc = {0, 0};&#10;    SIZE sizeWnd = {width, height};&#10;    BLENDFUNCTION blend = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};&#10;&#10;    UpdateLayeredWindow(monitor.hwnd, screenDC, nullptr, &amp;sizeWnd, monitor.memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow * self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                BeginPaint(hWnd, &amp;ps);&#10;&#10;                // 找到对应的监视器&#10;                for (auto &amp;monitor: self-&gt;monitors) {&#10;                    if (monitor.hwnd == hWnd &amp;&amp; monitor.memDC) {&#10;                        self-&gt;DrawCrosshair(monitor.memDC, monitor.rect);&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1;&#10;        case WM_SIZE:&#10;            if (self) {&#10;                // 找到对应的监视器并调整大小&#10;                for (auto &amp;monitor: self-&gt;monitors) {&#10;                    if (monitor.hwnd == hWnd) {&#10;                        CrosshairWindow::OnResize(monitor);&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;            return 0;&#10;        case WM_CLOSE:&#10;        case WM_QUIT:&#10;        case WM_NCDESTROY:&#10;        case WM_DESTROY:&#10;            if (g_mouseHook) {&#10;                UnhookWindowsHookEx(g_mouseHook);&#10;                g_mouseHook = nullptr;&#10;            }&#10;            exit(0);&#10;            break;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;void CrosshairWindow::DrawCrosshair(HDC hdc, const RECT&amp; monitorRect) const {&#10;    const int width = monitorRect.right - monitorRect.left;&#10;    const int height = monitorRect.bottom - monitorRect.top;&#10;&#10;    // 使用 GDI+ 进行抗锯齿绘制&#10;    Gdiplus::Graphics graphics(hdc);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;&#10;    // 将屏幕坐标转换为当前监视器的相对坐标&#10;    pt.x -= monitorRect.left;&#10;    pt.y -= monitorRect.top;&#10;&#10;    // 确保鼠标在当前监视器范围内&#10;    if (pt.x &lt; 0 || pt.x &gt;= width || pt.y &lt; 0 || pt.y &gt;= height) {&#10;        // 如果鼠标不在当前屏幕，直接返回（保持透明）&#10;        const HDC screenDC = GetDC(nullptr);&#10;        POINT ptSrc = {0, 0};&#10;        SIZE sizeWnd = {width, height};&#10;        BLENDFUNCTION blend = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};&#10;&#10;        HWND targetHwnd = nullptr;&#10;        for (const auto&amp; monitor : monitors) {&#10;            if (monitor.memDC == hdc) {&#10;                targetHwnd = monitor.hwnd;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (targetHwnd) {&#10;            UpdateLayeredWindow(targetHwnd, screenDC, nullptr, &amp;sizeWnd, hdc, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;        }&#10;        ReleaseDC(nullptr, screenDC);&#10;        return;&#10;    }&#10;&#10;    // 水平线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen const pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;        const int leftLength = std::min&lt;int&gt;(pt.x, width);&#10;        const int rightLength = std::min&lt;int&gt;(width - pt.x, width);&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x - leftLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x + rightLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;        );&#10;    }&#10;    // 垂直线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen const pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;        const int topLength = std::min&lt;int&gt;(pt.y, height);&#10;        const int bottomLength = std::min&lt;int&gt;(height - pt.y, height);&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y - topLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y + bottomLength)&#10;        );&#10;    }&#10;&#10;    // 更新分层窗口&#10;    const HDC screenDC = GetDC(nullptr);&#10;    POINT ptSrc = {0, 0};&#10;    SIZE sizeWnd = {width, height};&#10;    BLENDFUNCTION blend = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};&#10;&#10;    // 找到对应的窗口句柄&#10;    HWND targetHwnd = nullptr;&#10;    for (const auto&amp; monitor : monitors) {&#10;        if (monitor.memDC == hdc) {&#10;            targetHwnd = monitor.hwnd;&#10;            break;&#10;        }&#10;    }&#10;&#10;    if (targetHwnd) {&#10;        UpdateLayeredWindow(targetHwnd, screenDC, nullptr, &amp;sizeWnd, hdc, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;    }&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;&#10;// 全局鼠标钩子回调&#10;LRESULT CALLBACK CrosshairWindow::MouseProc(const int nCode, const WPARAM wParam, const LPARAM lParam) {&#10;    static auto last = std::chrono::steady_clock::now();&#10;    if (nCode == HC_ACTION &amp;&amp; wParam == WM_MOUSEMOVE &amp;&amp; g_instance) {&#10;        const auto now = std::chrono::steady_clock::now();&#10;        const auto diff = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - last).count();&#10;        if (diff &gt;= INTERVAL_mSEC) {&#10;            last = now;&#10;            g_instance-&gt;OnMouseMove();&#10;        }&#10;    }&#10;    return CallNextHookEx(g_mouseHook, nCode, wParam, lParam);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/crosshair.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/crosshair.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &lt;vector&gt;&#10;#include &quot;config.h&quot;&#10;&#10;struct MonitorInfo {&#10;    HMONITOR hMonitor;&#10;    RECT rect;&#10;    HWND hwnd;&#10;    HDC memDC;&#10;    HBITMAP hBmp;&#10;    bool needsUpdate;&#10;};&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;&#10;    ~CrosshairWindow();&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;    // 鼠标钩子接口&#10;    void OnMouseMove() const;&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    static BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData);&#10;&#10;    void DrawCrosshair(HDC hdc, const RECT &amp;monitorRect) const;&#10;&#10;    static void OnResize(MonitorInfo &amp;monitor);&#10;&#10;    void UpdateMonitors();&#10;&#10;    void CreateWindowForMonitor(MonitorInfo &amp;monitor);&#10;&#10;    void DestroyMonitorWindows();&#10;&#10;    MonitorInfo *FindMonitorContainingPoint(POINT pt);&#10;&#10;    HINSTANCE hInstance;&#10;    Config config;&#10;    bool visible;&#10;&#10;    // 多屏幕支持&#10;    std::vector&lt;MonitorInfo&gt; monitors;&#10;    bool monitorsChanged;&#10;&#10;    // 鼠标钩子&#10;    static HHOOK g_mouseHook;&#10;    static CrosshairWindow *g_instance;&#10;&#10;    static LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &lt;vector&gt;&#10;#include &quot;config.h&quot;&#10;&#10;struct MonitorInfo {&#10;    HMONITOR hMonitor;&#10;    RECT rect;&#10;    HWND hwnd;&#10;    HDC memDC;&#10;    HBITMAP hBmp;&#10;    bool needsUpdate;&#10;    bool hasMouseCursor; // 新增：标记是否有鼠标光标&#10;};&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;&#10;    ~CrosshairWindow();&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;    // 鼠标钩子接口&#10;    void OnMouseMove() const;&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    static BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData);&#10;&#10;    void DrawCrosshair(HDC hdc, const RECT &amp;monitorRect) const;&#10;&#10;    void ClearMonitor(MonitorInfo &amp;monitor) const; // 新增：清除屏幕内容&#10;&#10;    static void OnResize(MonitorInfo &amp;monitor);&#10;&#10;    void UpdateMonitors();&#10;&#10;    void CreateWindowForMonitor(MonitorInfo &amp;monitor);&#10;&#10;    void DestroyMonitorWindows();&#10;&#10;    MonitorInfo *FindMonitorContainingPoint(POINT pt);&#10;&#10;    HINSTANCE hInstance;&#10;    Config config;&#10;    bool visible;&#10;&#10;    // 多屏幕支持&#10;    std::vector&lt;MonitorInfo&gt; monitors;&#10;    bool monitorsChanged;&#10;    mutable POINT lastMousePos; // 新增：记录上一次鼠标位置&#10;    mutable bool lastMousePosValid; // 新增：标记上一次位置是否有效&#10;&#10;    // 鼠标钩子&#10;    static HHOOK g_mouseHook;&#10;    static CrosshairWindow *g_instance;&#10;&#10;    static LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>