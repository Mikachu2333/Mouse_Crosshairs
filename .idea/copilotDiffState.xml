<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.cpp" />
              <option name="originalContent" value="#include &quot;config.h&quot;&#10;&#10;bool Config::Load(const char *filename) {&#10;    // 横线&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey.mod |= MOD_SHIFT;&#10;    if (hotkey.mod &lt; 1 || hotkey.mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) hotkey.mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey.vk = ParseVK(vkStr);&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    UINT dpi = 96;&#10;    if (const HMODULE hUser32 = LoadLibraryA(&quot;User32.dll&quot;)) {&#10;        typedef UINT (WINAPI *GetDpiForSystem_t)();&#10;        if (const auto pGetDpiForSystem = reinterpret_cast&lt;GetDpiForSystem_t&gt;(GetProcAddress(hUser32, &quot;GetDpiForSystem&quot;))) {&#10;            dpi = pGetDpiForSystem();&#10;        } else {&#10;            const HDC hdc = GetDC(nullptr);&#10;            dpi = GetDeviceCaps(hdc, LOGPIXELSX);&#10;            ReleaseDC(nullptr, hdc);&#10;        }&#10;        FreeLibrary(hUser32);&#10;    }&#10;&#10;    const double scale = dpi / 96.0;&#10;    // 横线长度基于屏幕宽度&#10;    horizontal.length = static_cast&lt;int&gt;(screenWidth * scale);&#10;    // 竖线长度基于屏幕高度&#10;    vertical.length = static_cast&lt;int&gt;(screenHeight * scale);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config.h&quot;&#10;&#10;bool Config::Load(const char *filename) {&#10;    // 横线&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey.mod |= MOD_SHIFT;&#10;    if (hotkey.mod &lt; 1 || hotkey.mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) hotkey.mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey.vk = ParseVK(vkStr);&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    // 简化 DPI 获取逻辑，直接使用屏幕尺寸&#10;    horizontal.length = screenWidth;&#10;    vertical.length = screenHeight;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;struct LineConfig {&#10;    unsigned int length = 2222;&#10;    unsigned int width = 21;&#10;    unsigned int r = 233, g = 233, b = 233;&#10;    unsigned int alpha = 199;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;&#10;    unsigned int vk = VK_H;&#10;&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char *filename);&#10;&#10;    void AutoSetLength();&#10;&#10;    static int ParseVK(const char *str) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        // ReSharper disable once CppUseRangeAlgorithm&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.starts_with(&quot;vk_&quot;)) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        return VK_H;&#10;    }&#10;&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey.Clamp();&#10;    }&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;struct LineConfig {&#10;    unsigned int length = 2222;&#10;    unsigned int width = 21;&#10;    unsigned int r = 233, g = 233, b = 233;&#10;    unsigned int alpha = 199;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;&#10;    unsigned int vk = VK_H;&#10;&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char *filename);&#10;&#10;    void AutoSetLength();&#10;&#10;    static int ParseVK(const char *str) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.length() &gt; 3 &amp;&amp; key.substr(0, 3) == &quot;vk_&quot;) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        return VK_H;&#10;    }&#10;&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey.Clamp();&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.cpp" />
              <option name="originalContent" value="#include &quot;config_file_util.h&quot;&#10;#include &lt;windows.h&gt;&#10;#include &lt;fstream&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path() {&#10;    char exePath[MAX_PATH] = {};&#10;    GetModuleFileNameA(nullptr, exePath, MAX_PATH);&#10;    std::string path(exePath);&#10;    if (const size_t pos = path.find_last_of(&quot;\\/&quot;); pos != std::string::npos) {&#10;        path = path.substr(0, pos + 1);&#10;    } else {&#10;        path = &quot;./&quot;;&#10;    }&#10;    return path + &quot;crosshair.ini&quot;;&#10;}&#10;&#10;// 写入默认配置内容&#10;static void write_default_config(const std::string &amp;path) {&#10;    std::ofstream ofs(path, std::ios::out | std::ios::trunc);&#10;    ofs &lt;&lt; DEFAULT_INI;&#10;    ofs.close();&#10;}&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string &amp;path) {&#10;    const DWORD attr = GetFileAttributesA(path.c_str());&#10;    if (attr == INVALID_FILE_ATTRIBUTES || attr &amp; FILE_ATTRIBUTE_DIRECTORY) {&#10;        write_default_config(path);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config_file_util.h&quot;&#13;&#10;#include &lt;windows.h&gt;&#13;&#10;#include &lt;fstream&gt;&#13;&#10;&#13;&#10;// 获取配置文件绝对路径（与exe同目录）&#13;&#10;std::string get_config_path() {&#13;&#10;    char path[MAX_PATH];&#13;&#10;    GetModuleFileNameA(nullptr, path, MAX_PATH);&#13;&#10;    std::string exePath = path;&#13;&#10;    size_t pos = exePath.find_last_of(&quot;\\/&quot;);&#13;&#10;    if (pos != std::string::npos) {&#13;&#10;        exePath = exePath.substr(0, pos + 1);&#13;&#10;    }&#13;&#10;    return exePath + &quot;config.ini&quot;;&#13;&#10;}&#13;&#10;&#13;&#10;// 如果配置文件不存在则创建&#13;&#10;void ensure_config_exists(const std::string &amp;path) {&#13;&#10;    std::ifstream file(path);&#13;&#10;    if (!file.good()) {&#13;&#10;        std::ofstream outFile(path);&#13;&#10;        if (outFile.is_open()) {&#13;&#10;            outFile &lt;&lt; DEFAULT_INI;&#13;&#10;            outFile.close();&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.h" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;string&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path();&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string&amp; path);&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.cpp" />
              <option name="originalContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 16&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 使用FALSE避免背景擦除&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha的DIB&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int left = std::max(0, pt.x - halfLength);&#10;        int right = std::min(width, pt.x + halfLength);&#10;&#10;        if (left &lt; right) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(left),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;                static_cast&lt;Gdiplus::REAL&gt;(right),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;            );&#10;        }&#10;    }&#10;&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int top = std::max(0, pt.y - halfLength);&#10;        int bottom = std::min(height, pt.y + halfLength);&#10;&#10;        if (top &lt; bottom) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(top),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(bottom)&#10;            );&#10;        }&#10;    }&#10;&#10;    POINT ptSrc = { 0, 0 };&#10;    SIZE sizeWnd = { width, height };&#10;    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#include &lt;algorithm&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 16&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 使用FALSE避免背景擦除&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha的DIB&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int left = std::max(0, pt.x - halfLength);&#10;        int right = std::min(width, pt.x + halfLength);&#10;&#10;        if (left &lt; right) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(left),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;                static_cast&lt;Gdiplus::REAL&gt;(right),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;            );&#10;        }&#10;    }&#10;&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int top = std::max(0, pt.y - halfLength);&#10;        int bottom = std::min(height, pt.y + halfLength);&#10;&#10;        if (top &lt; bottom) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(top),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(bottom)&#10;            );&#10;        }&#10;    }&#10;&#10;    POINT ptSrc = { 0, 0 };&#10;    SIZE sizeWnd = { width, height };&#10;    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;    ~CrosshairWindow();&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.ini">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.ini" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="[Horizontal]&#10;Length=60&#10;Width=3&#10;R=0&#10;G=255&#10;B=0&#10;Alpha=180&#10;&#10;[Vertical]&#10;Length=80&#10;Width=2&#10;R=255&#10;G=0&#10;B=0&#10;Alpha=200&#10;&#10;[Hotkey]&#10;; Mod为修饰键位掩码，见WinAPI RegisterHotKey文档&#10;; 1=Alt, 2=Ctrl, 4=Shift, 8=Win，可组合&#10;Mod=3&#10;; VK可为单字母（如H），或虚拟键码（如0x70为F1）&#10;VK=H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.cpp" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#include &quot;hotkey.h&quot;&#10;&#10;#define HOTKEY_ID 0x1234&#10;&#10;void HotkeyManager::RegisterToggleHotkey(const HotkeyConfig&amp; cfg) {&#10;    RegisterHotKey(nullptr, HOTKEY_ID, cfg.mod, cfg.vk);&#10;}&#10;&#10;bool HotkeyManager::IsToggleHotkey(const MSG&amp; msg) {&#10;    return msg.message == WM_HOTKEY &amp;&amp; msg.wParam == HOTKEY_ID;&#10;}&#10;&#10;void HotkeyManager::UnregisterAll() {&#10;    UnregisterHotKey(nullptr, HOTKEY_ID);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.h" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class HotkeyManager {&#10;public:&#10;    void RegisterToggleHotkey(const HotkeyConfig&amp; cfg);&#10;    bool IsToggleHotkey(const MSG&amp; msg);&#10;    void UnregisterAll();&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.cpp" />
              <option name="originalContent" value="#include &lt;windows.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#include &quot;src/crosshair.h&quot;&#10;#include &quot;src/config.h&quot;&#10;#include &quot;src/hotkey.h&quot;&#10;#include &quot;src/config_file_util.h&quot;&#10;&#10;using namespace Gdiplus;&#10;&#10;// GDI+ 初始化令牌&#10;ULONG_PTR gdiToken;&#10;&#10;int WINAPI WinMain(const HINSTANCE hInstance, HINSTANCE, LPSTR, int) {&#10;    // 创建互斥体防止程序重复运行&#10;    const HANDLE hMutex = CreateMutexA(nullptr, FALSE, &quot;F5B6239126A64833BE094D6DC8DC1951&quot;);&#10;    if (GetLastError() == ERROR_ALREADY_EXISTS) {&#10;        MessageBoxA(nullptr, &quot;Already Exist.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        return -1;&#10;    }&#10;&#10;    // 设置 DPI 感知，确保在高分辨率屏幕上正确显示&#10;    SetProcessDPIAware();&#10;&#10;    // 初始化 GDI+&#10;    GdiplusStartupInput gdiplusStartupInput;&#10;    GdiplusStartup(&amp;gdiToken, &amp;gdiplusStartupInput, nullptr);&#10;&#10;    // 获取配置文件路径并确保文件存在&#10;    const std::string configPath = get_config_path();&#10;    ensure_config_exists(configPath);&#10;&#10;    // 加载配置文件&#10;    Config config;&#10;    if (!config.Load(configPath.c_str())) {&#10;        MessageBoxA(nullptr, &quot;Error load config, use default values.&quot;, &quot;Warning&quot;, MB_OK | MB_ICONINFORMATION);&#10;    }&#10;    config.AutoSetLength();&#10;&#10;    // 创建十字准星窗口&#10;    CrosshairWindow crosshair(hInstance, config);&#10;    if (!crosshair.Create()) {&#10;        MessageBoxA(nullptr, &quot;Error creating Crosshair window.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        GdiplusShutdown(gdiToken);&#10;        return 1;&#10;    }&#10;&#10;    // 注册全局热键&#10;    HotkeyManager hotkey;&#10;    hotkey.RegisterToggleHotkey(config.hotkey_h_s,config.hotkey_exit);&#10;&#10;    // 主消息循环&#10;    MSG msg;&#10;    while (GetMessage(&amp;msg, nullptr, 0, 0)) {&#10;        if (hotkey.IsToggleHotkey(msg)) {&#10;            crosshair.ToggleVisible();&#10;            continue;&#10;        }&#10;        TranslateMessage(&amp;msg);&#10;        DispatchMessage(&amp;msg);&#10;    }&#10;&#10;    // 清理资源&#10;    hotkey.UnregisterAll();&#10;    GdiplusShutdown(gdiToken);&#10;    if (hMutex) CloseHandle(hMutex);&#10;    return 0;&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;windows.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#include &quot;src/crosshair.h&quot;&#10;#include &quot;src/config.h&quot;&#10;#include &quot;src/hotkey.h&quot;&#10;#include &quot;src/config_file_util.h&quot;&#10;&#10;using namespace Gdiplus;&#10;&#10;// GDI+ 初始化令牌&#10;ULONG_PTR gdiToken;&#10;&#10;int WINAPI WinMain(const HINSTANCE hInstance, HINSTANCE, LPSTR, int) {&#10;    // 创建互斥体防止程序重复运行&#10;    const HANDLE hMutex = CreateMutexA(nullptr, FALSE, &quot;F5B6239126A64833BE094D6DC8DC1951&quot;);&#10;    if (GetLastError() == ERROR_ALREADY_EXISTS) {&#10;        MessageBoxA(nullptr, &quot;Already Exist.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        return -1;&#10;    }&#10;&#10;    // 设置 DPI 感知，确保在高分辨率屏幕上正确显示&#10;    SetProcessDPIAware();&#10;&#10;    // 初始化 GDI+&#10;    GdiplusStartupInput gdiplusStartupInput;&#10;    GdiplusStartup(&amp;gdiToken, &amp;gdiplusStartupInput, nullptr);&#10;&#10;    // 获取配置文件路径并确保文件存在&#10;    const std::string configPath = get_config_path();&#10;    ensure_config_exists(configPath);&#10;&#10;    // 加载配置文件&#10;    Config config;&#10;    if (!config.Load(configPath.c_str())) {&#10;        MessageBoxA(nullptr, &quot;Error load config, use default values.&quot;, &quot;Warning&quot;, MB_OK | MB_ICONINFORMATION);&#10;    }&#10;    config.AutoSetLength();&#10;&#10;    // 创建十字准星窗口&#10;    CrosshairWindow crosshair(hInstance, config);&#10;    if (!crosshair.Create()) {&#10;        MessageBoxA(nullptr, &quot;Error creating Crosshair window.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        GdiplusShutdown(gdiToken);&#10;        return 1;&#10;    }&#10;&#10;    // 注册全局热键&#10;    HotkeyManager hotkey;&#10;    hotkey.RegisterToggleHotkey(config.hotkey_h_s,config.hotkey_exit);&#10;&#10;    // 主消息循环&#10;    MSG msg;&#10;    while (GetMessage(&amp;msg, nullptr, 0, 0)) {&#10;        if (hotkey.IsToggleHotkey(msg)) {&#10;            crosshair.ToggleVisible();&#10;            continue;&#10;        }&#10;        if (hotkey.IsExitHotkey(msg)) {&#10;            // 退出程序&#10;            break;&#10;        }&#10;        TranslateMessage(&amp;msg);&#10;        DispatchMessage(&amp;msg);&#10;    }&#10;&#10;    // 清理资源&#10;    hotkey.UnregisterAll();&#10;    GdiplusShutdown(gdiToken);&#10;    if (hMutex) CloseHandle(hMutex);&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config.cpp" />
              <option name="originalContent" value="#include &quot;config.h&quot;&#10;&#10;// 从 INI 文件加载配置&#10;bool Config::Load(const char *filename) {&#10;    // 加载横线配置&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 加载竖线配置&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 加载显示/隐藏热键配置&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey_h_s.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    // 解析修饰键组合&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_SHIFT;&#10;    if (hotkey_h_s.mod &lt; 1 || hotkey_h_s.mod &gt; MOD_CONTROL | MOD_SHIFT | MOD_WIN | MOD_ALT)&#10;        hotkey_h_s.mod = MOD_CONTROL | MOD_WIN | MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey_h_s.vk = ParseVK(vkStr, 'h');&#10;&#10;    // 加载退出热键配置&#10;    char exit_modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, exit_modStr, sizeof(exit_modStr), filename);&#10;    hotkey_exit.mod = 0;&#10;    std::string exit_modStrLower = exit_modStr;&#10;    for (auto &amp;c: exit_modStrLower) c = tolower(c);&#10;    // 解析修饰键组合&#10;    if (exit_modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey_exit.mod |= MOD_CONTROL;&#10;    if (exit_modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey_exit.mod |= MOD_ALT;&#10;    if (exit_modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey_exit.mod |= MOD_WIN;&#10;    if (exit_modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey_exit.mod |= MOD_SHIFT;&#10;    if (hotkey_exit.mod &lt; 1 || hotkey_exit.mod &gt; MOD_CONTROL | MOD_SHIFT | MOD_WIN | MOD_ALT)&#10;        hotkey_exit.mod = MOD_CONTROL | MOD_WIN | MOD_ALT;&#10;&#10;    char exit_vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey_exit.vk = ParseVK(vkStr, 'e');&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;// 根据屏幕尺寸自动设置十字准星长度&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    // 设置为全屏幕宽度和高度&#10;    horizontal.length = screenWidth;&#10;    vertical.length = screenHeight;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config.h&quot;&#10;&#10;// 从 INI 文件加载配置&#10;bool Config::Load(const char *filename) {&#10;    // 加载横线配置&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 加载竖线配置&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 加载显示/隐藏热键配置&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey_h_s.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    // 解析修饰键组合&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey_h_s.mod |= MOD_SHIFT;&#10;    if (hotkey_h_s.mod &lt; 1 || hotkey_h_s.mod &gt; MOD_CONTROL | MOD_SHIFT | MOD_WIN | MOD_ALT)&#10;        hotkey_h_s.mod = MOD_CONTROL | MOD_WIN | MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hide_Show_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey_h_s.vk = ParseVK(vkStr, 'h');&#10;&#10;    // 加载退出热键配置&#10;    char exit_modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, exit_modStr, sizeof(exit_modStr), filename);&#10;    hotkey_exit.mod = 0;&#10;    std::string exit_modStrLower = exit_modStr;&#10;    for (auto &amp;c: exit_modStrLower) c = tolower(c);&#10;    // 解析修饰键组合&#10;    if (exit_modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey_exit.mod |= MOD_CONTROL;&#10;    if (exit_modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey_exit.mod |= MOD_ALT;&#10;    if (exit_modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey_exit.mod |= MOD_WIN;&#10;    if (exit_modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey_exit.mod |= MOD_SHIFT;&#10;    if (hotkey_exit.mod &lt; 1 || hotkey_exit.mod &gt; MOD_CONTROL | MOD_SHIFT | MOD_WIN | MOD_ALT)&#10;        hotkey_exit.mod = MOD_CONTROL | MOD_WIN | MOD_ALT;&#10;&#10;    char exit_vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Exit_Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, exit_vkStr, sizeof(exit_vkStr), filename);&#10;    hotkey_exit.vk = ParseVK(exit_vkStr, 'e');&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;// 根据屏幕尺寸自动设置十字准星长度&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    // 设置为全屏幕宽度和高度&#10;    horizontal.length = screenWidth;&#10;    vertical.length = screenHeight;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;struct LineConfig {&#10;    unsigned int length = 2222;&#10;    unsigned int width = 21;&#10;    unsigned int r = 233, g = 233, b = 233;&#10;    unsigned int alpha = 199;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;&#10;    unsigned int vk = VK_H;&#10;&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL | MOD_SHIFT | MOD_WIN | MOD_ALT) mod = MOD_CONTROL | MOD_WIN | MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey_h_s;&#10;    HotkeyConfig hotkey_exit;&#10;&#10;    bool Load(const char *filename);&#10;&#10;    void AutoSetLength();&#10;&#10;    static int ParseVK(const char *str, char mode) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        // ReSharper disable once CppUseRangeAlgorithm&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.length() &gt; 3 &amp;&amp; key.substr(0, 3) == &quot;vk_&quot;) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        switch (mode) {&#10;            case 'h': return VK_H;&#10;            case 'e': return VK_ESCAPE;&#10;            default: return VK_NONAME;&#10;        }&#10;    }&#10;&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey_h_s.Clamp();&#10;        hotkey_exit.Clamp();&#10;    }&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// 虚拟键码枚举&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;// 单条线配置&#10;struct LineConfig {&#10;    unsigned int length = 2222;  // 线条长度&#10;    unsigned int width = 21;     // 线条宽度&#10;    unsigned int r = 233, g = 233, b = 233;  // RGB 颜色值&#10;    unsigned int alpha = 199;    // 透明度&#10;&#10;    // 限制值在有效范围内&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;// 热键配置&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;  // 修饰键组合&#10;    unsigned int vk = VK_H;  // 虚拟键码&#10;&#10;    // 限制值在有效范围内&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL | MOD_SHIFT | MOD_WIN | MOD_ALT) mod = MOD_CONTROL | MOD_WIN | MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;// 主配置类&#10;struct Config {&#10;    LineConfig horizontal;    // 水平线配置&#10;    LineConfig vertical;      // 垂直线配置&#10;    HotkeyConfig hotkey_h_s;  // 显示/隐藏热键&#10;    HotkeyConfig hotkey_exit; // 退出热键&#10;&#10;    // 从文件加载配置&#10;    bool Load(const char *filename);&#10;&#10;    // 根据屏幕尺寸自动设置线条长度&#10;    void AutoSetLength();&#10;&#10;    // 解析虚拟键码字符串&#10;    static int ParseVK(const char *str, char mode) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        // ReSharper disable once CppUseRangeAlgorithm&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.length() &gt; 3 &amp;&amp; key.substr(0, 3) == &quot;vk_&quot;) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        switch (mode) {&#10;            case 'h': return VK_H;&#10;            case 'e': return VK_ESCAPE;&#10;            default: return VK_NONAME;&#10;        }&#10;    }&#10;&#10;    // 限制所有配置值在有效范围内&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey_h_s.Clamp();&#10;        hotkey_exit.Clamp();&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config_file_util.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config_file_util.cpp" />
              <option name="originalContent" value="#include &quot;./config_file_util.h&quot;&#10;#include &lt;windows.h&gt;&#10;#include &lt;fstream&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path() {&#10;    char path[MAX_PATH];&#10;    GetModuleFileNameA(nullptr, path, MAX_PATH);&#10;    std::string exePath = path;&#10;    size_t pos = exePath.find_last_of(&quot;\\/&quot;);&#10;    if (pos != std::string::npos) {&#10;        exePath = exePath.substr(0, pos + 1);&#10;    }&#10;    return exePath + &quot;crosshair.ini&quot;;&#10;}&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string &amp;path) {&#10;    std::ifstream file(path);&#10;    if (!file.good()) {&#10;        std::ofstream outFile(path);&#10;        if (outFile.is_open()) {&#10;            outFile &lt;&lt; DEFAULT_INI;&#10;            outFile.close();&#10;            MessageBoxA(nullptr, &quot;Crete Config Successfully.&quot;, &quot;Success&quot;, MB_OK | MB_ICONINFORMATION);&#10;            exit(0);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;./config_file_util.h&quot;&#10;#include &lt;windows.h&gt;&#10;#include &lt;fstream&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path() {&#10;    char path[MAX_PATH];&#10;    GetModuleFileNameA(nullptr, path, MAX_PATH);&#10;    std::string exePath = path;&#10;    size_t pos = exePath.find_last_of(&quot;\\/&quot;);&#10;    if (pos != std::string::npos) {&#10;        exePath = exePath.substr(0, pos + 1);&#10;    }&#10;    return exePath + &quot;crosshair.ini&quot;;&#10;}&#10;&#10;// 检查配置文件是否存在，不存在则创建默认配置&#10;void ensure_config_exists(const std::string &amp;path) {&#10;    std::ifstream file(path);&#10;    if (!file.good()) {&#10;        std::ofstream outFile(path);&#10;        if (outFile.is_open()) {&#10;            outFile &lt;&lt; DEFAULT_INI;&#10;            outFile.close();&#10;            MessageBoxA(nullptr, &quot;Crete Config Successfully.&quot;, &quot;Success&quot;, MB_OK | MB_ICONINFORMATION);&#10;            exit(0);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/crosshair.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/crosshair.cpp" />
              <option name="originalContent" value="#include &quot;./crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#include &lt;algorithm&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 16&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 使用FALSE避免背景擦除&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha的DIB&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int leftLength = std::min&lt;int&gt;(pt.x, width);&#10;        int rightLength = std::min&lt;int&gt;(width - pt.x, width);&#10;&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x - leftLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x + rightLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;        );&#10;    }&#10;&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int topLength = std::min&lt;int&gt;(pt.y, height);&#10;        int bottomLength = std::min&lt;int&gt;(height - pt.y, height);&#10;&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y - topLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y + bottomLength)&#10;        );&#10;    }&#10;&#10;    POINT ptSrc = {0, 0};&#10;    SIZE sizeWnd = {width, height};&#10;    BLENDFUNCTION blend = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;./crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#include &lt;algorithm&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001      // 定时器 ID&#10;#define TIMER_INTERVAL 16    // 刷新间隔（约60FPS）&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;// 创建透明的分层窗口&#10;bool CrosshairWindow::Create() {&#10;    // 注册窗口类&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    // 创建全屏透明窗口&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    // 启动刷新定时器&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;// 切换十字准星显示状态&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;// 窗口过程函数&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除保持透明&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 触发重绘，跟随鼠标&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;// 绘制跟随鼠标的十字准星&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha通道的DIB位图&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    // 使用 GDI+ 进行抗锯齿绘制&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    // 获取鼠标当前位置&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 绘制水平线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        // 计算线条长度，不超出屏幕边界&#10;        int leftLength = std::min&lt;int&gt;(pt.x, width);&#10;        int rightLength = std::min&lt;int&gt;(width - pt.x, width);&#10;&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x - leftLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x + rightLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;        );&#10;    }&#10;&#10;    // 绘制垂直线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        // 计算线条长度，不超出屏幕边界&#10;        int topLength = std::min&lt;int&gt;(pt.y, height);&#10;        int bottomLength = std::min&lt;int&gt;(height - pt.y, height);&#10;&#10;        graphics.DrawLine(&#10;            &amp;pen,&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y - topLength),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;            static_cast&lt;Gdiplus::REAL&gt;(pt.y + bottomLength)&#10;        );&#10;    }&#10;&#10;    // 更新分层窗口，实现透明效果&#10;    POINT ptSrc = {0, 0};&#10;    SIZE sizeWnd = {width, height};&#10;    BLENDFUNCTION blend = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    // 清理资源&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/crosshair.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/crosshair.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;&#10;    ~CrosshairWindow();&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;// 十字准星窗口类&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;&#10;    ~CrosshairWindow();&#10;&#10;    // 创建分层窗口&#10;    bool Create();&#10;&#10;    // 切换十字准星显示状态&#10;    void ToggleVisible();&#10;&#10;private:&#10;    // 窗口过程函数&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    // 绘制十字准星&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;  // 应用程序实例&#10;    HWND hwnd;           // 窗口句柄&#10;    Config config;       // 配置信息&#10;    bool visible;        // 当前显示状态&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hotkey.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hotkey.cpp" />
              <option name="originalContent" value="#include &quot;./hotkey.h&quot;&#10;&#10;// 热键 ID 常量&#10;#define HOTKEY_ID 2039166592   // 显示/隐藏热键 ID&#10;#define HOTKEY_ID2 2078194518  // 退出程序热键 ID&#10;&#10;// 注册显示/隐藏和退出热键&#10;void HotkeyManager::RegisterToggleHotkey(const HotkeyConfig &amp;cfg_h_s,const HotkeyConfig &amp;cfg_exit) {&#10;    RegisterHotKey(nullptr, HOTKEY_ID, cfg_h_s.mod, cfg_h_s.vk);&#10;    RegisterHotKey(nullptr, HOTKEY_ID2, cfg_exit.mod, cfg_exit.vk);&#10;}&#10;&#10;// 检查消息是否为注册的热键&#10;bool HotkeyManager::IsToggleHotkey(const MSG &amp;msg) {&#10;    return msg.message == WM_HOTKEY &amp;&amp; (msg.wParam == HOTKEY_ID || msg.wParam == HOTKEY_ID2);&#10;}&#10;&#10;// 注销所有热键&#10;void HotkeyManager::UnregisterAll() {&#10;    UnregisterHotKey(nullptr, HOTKEY_ID);&#10;    UnregisterHotKey(nullptr, HOTKEY_ID2);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;./hotkey.h&quot;&#10;&#10;// 热键 ID 常量&#10;#define HOTKEY_ID 2039166592   // 显示/隐藏热键 ID&#10;#define HOTKEY_ID2 2078194518  // 退出程序热键 ID&#10;&#10;// 注册显示/隐藏和退出热键&#10;void HotkeyManager::RegisterToggleHotkey(const HotkeyConfig &amp;cfg_h_s,const HotkeyConfig &amp;cfg_exit) {&#10;    RegisterHotKey(nullptr, HOTKEY_ID, cfg_h_s.mod, cfg_h_s.vk);&#10;    RegisterHotKey(nullptr, HOTKEY_ID2, cfg_exit.mod, cfg_exit.vk);&#10;}&#10;&#10;// 检查消息是否为显示/隐藏热键&#10;bool HotkeyManager::IsToggleHotkey(const MSG &amp;msg) {&#10;    return msg.message == WM_HOTKEY &amp;&amp; msg.wParam == HOTKEY_ID;&#10;}&#10;&#10;// 检查消息是否为退出热键&#10;bool HotkeyManager::IsExitHotkey(const MSG &amp;msg) {&#10;    return msg.message == WM_HOTKEY &amp;&amp; msg.wParam == HOTKEY_ID2;&#10;}&#10;&#10;// 注销所有热键&#10;void HotkeyManager::UnregisterAll() {&#10;    UnregisterHotKey(nullptr, HOTKEY_ID);&#10;    UnregisterHotKey(nullptr, HOTKEY_ID2);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hotkey.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hotkey.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class HotkeyManager {&#10;public:&#10;    static void RegisterToggleHotkey(const HotkeyConfig &amp;cfg_h_s,const HotkeyConfig &amp;cfg_exit);&#10;&#10;    static bool IsToggleHotkey(const MSG &amp;msg);&#10;&#10;    static void UnregisterAll();&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#13;&#10;#include &lt;windows.h&gt;&#13;&#10;#include &quot;config.h&quot;&#13;&#10;&#13;&#10;class HotkeyManager {&#13;&#10;public:&#13;&#10;    static void RegisterToggleHotkey(const HotkeyConfig &amp;cfg_h_s,const HotkeyConfig &amp;cfg_exit);&#13;&#10;&#13;&#10;    static bool IsToggleHotkey(const MSG &amp;msg);&#13;&#10;&#13;&#10;    static bool IsExitHotkey(const MSG &amp;msg);&#13;&#10;&#13;&#10;    static void UnregisterAll();&#13;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>