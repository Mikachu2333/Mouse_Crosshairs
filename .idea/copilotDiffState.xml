<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.31)&#10;project(mouse_crosshair)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;&#10;add_executable(mouse_crosshair main.cpp)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.31)&#10;project(mouse_crosshair)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;&#10;add_executable(mouse_crosshair&#10;    main.cpp&#10;    crosshair.cpp&#10;    config.cpp&#10;    hotkey.cpp&#10;)&#10;&#10;target_link_libraries(mouse_crosshair&#10;    user32&#10;    gdi32&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.cpp" />
              <option name="originalContent" value="#include &quot;config.h&quot;&#10;&#10;bool Config::Load(const char *filename) {&#10;    // 横线&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey.mod |= MOD_SHIFT;&#10;    if (hotkey.mod &lt; 1 || hotkey.mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) hotkey.mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey.vk = ParseVK(vkStr);&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    UINT dpi = 96;&#10;    if (const HMODULE hUser32 = LoadLibraryA(&quot;User32.dll&quot;)) {&#10;        typedef UINT (WINAPI *GetDpiForSystem_t)();&#10;        if (const auto pGetDpiForSystem = reinterpret_cast&lt;GetDpiForSystem_t&gt;(GetProcAddress(hUser32, &quot;GetDpiForSystem&quot;))) {&#10;            dpi = pGetDpiForSystem();&#10;        } else {&#10;            const HDC hdc = GetDC(nullptr);&#10;            dpi = GetDeviceCaps(hdc, LOGPIXELSX);&#10;            ReleaseDC(nullptr, hdc);&#10;        }&#10;        FreeLibrary(hUser32);&#10;    }&#10;&#10;    const double scale = dpi / 96.0;&#10;    // 横线长度基于屏幕宽度&#10;    horizontal.length = static_cast&lt;int&gt;(screenWidth * scale);&#10;    // 竖线长度基于屏幕高度&#10;    vertical.length = static_cast&lt;int&gt;(screenHeight * scale);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config.h&quot;&#10;&#10;bool Config::Load(const char *filename) {&#10;    // 横线&#10;    horizontal.width = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Width&quot;, horizontal.width, filename);&#10;    horizontal.r = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;R&quot;, horizontal.r, filename);&#10;    horizontal.g = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;G&quot;, horizontal.g, filename);&#10;    horizontal.b = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;B&quot;, horizontal.b, filename);&#10;    horizontal.alpha = GetPrivateProfileIntA(&quot;Horizontal&quot;, &quot;Alpha&quot;, horizontal.alpha, filename);&#10;&#10;    // 竖线&#10;    vertical.width = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Width&quot;, vertical.width, filename);&#10;    vertical.r = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;R&quot;, vertical.r, filename);&#10;    vertical.g = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;G&quot;, vertical.g, filename);&#10;    vertical.b = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;B&quot;, vertical.b, filename);&#10;    vertical.alpha = GetPrivateProfileIntA(&quot;Vertical&quot;, &quot;Alpha&quot;, vertical.alpha, filename);&#10;&#10;    // 快捷键&#10;    char modStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;Mod&quot;, &quot;&quot;, modStr, sizeof(modStr), filename);&#10;    hotkey.mod = 0;&#10;    std::string modStrLower = modStr;&#10;    for (auto &amp;c: modStrLower) c = tolower(c);&#10;    if (modStrLower.find(&quot;ctrl&quot;) != std::string::npos) hotkey.mod |= MOD_CONTROL;&#10;    if (modStrLower.find(&quot;alt&quot;) != std::string::npos) hotkey.mod |= MOD_ALT;&#10;    if (modStrLower.find(&quot;win&quot;) != std::string::npos) hotkey.mod |= MOD_WIN;&#10;    if (modStrLower.find(&quot;shift&quot;) != std::string::npos) hotkey.mod |= MOD_SHIFT;&#10;    if (hotkey.mod &lt; 1 || hotkey.mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) hotkey.mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;&#10;    char vkStr[64] = {};&#10;    GetPrivateProfileStringA(&quot;Hotkey&quot;, &quot;VK&quot;, &quot;&quot;, vkStr, sizeof(vkStr), filename);&#10;    hotkey.vk = ParseVK(vkStr);&#10;&#10;    ClampAll();&#10;    return true;&#10;}&#10;&#10;void Config::AutoSetLength() {&#10;    const int screenWidth = GetSystemMetrics(SM_CXSCREEN);&#10;    const int screenHeight = GetSystemMetrics(SM_CYSCREEN);&#10;&#10;    // 简化 DPI 获取逻辑，直接使用屏幕尺寸&#10;    horizontal.length = screenWidth;&#10;    vertical.length = screenHeight;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;struct LineConfig {&#10;    unsigned int length = 2222;&#10;    unsigned int width = 21;&#10;    unsigned int r = 233, g = 233, b = 233;&#10;    unsigned int alpha = 199;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;&#10;    unsigned int vk = VK_H;&#10;&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char *filename);&#10;&#10;    void AutoSetLength();&#10;&#10;    static int ParseVK(const char *str) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        // ReSharper disable once CppUseRangeAlgorithm&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.starts_with(&quot;vk_&quot;)) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        return VK_H;&#10;    }&#10;&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey.Clamp();&#10;    }&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cctype&gt;&#10;#include &lt;string&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;enum VKs {&#10;    VK_0 = 0x30,&#10;    VK_1 = 0x31,&#10;    VK_2 = 0x32,&#10;    VK_3 = 0x33,&#10;    VK_4 = 0x34,&#10;    VK_5 = 0x35,&#10;    VK_6 = 0x36,&#10;    VK_7 = 0x37,&#10;    VK_8 = 0x38,&#10;    VK_9 = 0x39,&#10;    VK_A = 0x41,&#10;    VK_B = 0x42,&#10;    VK_C = 0x43,&#10;    VK_D = 0x44,&#10;    VK_E = 0x45,&#10;    VK_F = 0x46,&#10;    VK_G = 0x47,&#10;    VK_H = 0x48,&#10;    VK_I = 0x49,&#10;    VK_J = 0x4A,&#10;    VK_K = 0x4B,&#10;    VK_L = 0x4C,&#10;    VK_M = 0x4D,&#10;    VK_N = 0x4E,&#10;    VK_O = 0x4F,&#10;    VK_P = 0x50,&#10;    VK_Q = 0x51,&#10;    VK_R = 0x52,&#10;    VK_S = 0x53,&#10;    VK_T = 0x54,&#10;    VK_U = 0x55,&#10;    VK_V = 0x56,&#10;    VK_W = 0x57,&#10;    VK_X = 0x58,&#10;    VK_Y = 0x59,&#10;    VK_Z = 0x5A,&#10;};&#10;&#10;struct LineConfig {&#10;    unsigned int length = 2222;&#10;    unsigned int width = 21;&#10;    unsigned int r = 233, g = 233, b = 233;&#10;    unsigned int alpha = 199;&#10;&#10;    void Clamp() {&#10;        if (length &lt; 1) length = 1;&#10;        if (width &lt; 1) width = 1;&#10;        if (width &gt; 100) width = 20;&#10;        r = std::clamp(r, 0u, 255u);&#10;        g = std::clamp(g, 0u, 255u);&#10;        b = std::clamp(b, 0u, 255u);&#10;        alpha = std::clamp(alpha, 0u, 255u);&#10;    }&#10;};&#10;&#10;struct HotkeyConfig {&#10;    unsigned int mod = MOD_WIN | MOD_CONTROL | MOD_ALT;&#10;    unsigned int vk = VK_H;&#10;&#10;    void Clamp() {&#10;        if (mod &lt; 1 || mod &gt; MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_ALT) mod = MOD_CONTROL|MOD_WIN|MOD_ALT;&#10;        const bool valid =&#10;                (vk &gt;= VK_XBUTTON1 &amp;&amp; vk &lt;= VK_XBUTTON2) ||&#10;                (vk &gt;= VK_BACK &amp;&amp; vk &lt;= VK_TAB) ||&#10;                vk == VK_SPACE ||&#10;                (vk &gt;= VK_NUMPAD0 &amp;&amp; vk &lt;= VK_NUMPAD5) ||&#10;                (vk &gt;= VK_0 &amp;&amp; vk &lt;= VK_9) ||&#10;                (vk &gt;= VK_A &amp;&amp; vk &lt;= VK_Z);&#10;        if (!valid) vk = VK_H;&#10;    }&#10;};&#10;&#10;struct Config {&#10;    LineConfig horizontal;&#10;    LineConfig vertical;&#10;    HotkeyConfig hotkey;&#10;&#10;    bool Load(const char *filename);&#10;&#10;    void AutoSetLength();&#10;&#10;    static int ParseVK(const char *str) {&#10;        static const std::unordered_map&lt;std::string, int&gt; vkMap = {&#10;            {&quot;xbutton1&quot;, VK_XBUTTON1}, {&quot;xbutton2&quot;, VK_XBUTTON2}, {&quot;backspace&quot;, VK_BACK},&#10;            {&quot;tab&quot;, VK_TAB}, {&quot;space&quot;, VK_SPACE}, {&quot;numpad0&quot;, VK_NUMPAD0},&#10;            {&quot;numpad1&quot;, VK_NUMPAD1}, {&quot;numpad2&quot;, VK_NUMPAD2}, {&quot;numpad3&quot;, VK_NUMPAD3},&#10;            {&quot;numpad4&quot;, VK_NUMPAD4}, {&quot;numpad5&quot;, VK_NUMPAD5}, {&quot;numpad6&quot;, VK_NUMPAD6},&#10;            {&quot;numpad7&quot;, VK_NUMPAD7}, {&quot;numpad8&quot;, VK_NUMPAD8}, {&quot;numpad9&quot;, VK_NUMPAD9},&#10;            {&quot;0&quot;, VK_0}, {&quot;1&quot;, VK_1}, {&quot;2&quot;, VK_2}, {&quot;3&quot;, VK_3}, {&quot;4&quot;, VK_4},&#10;            {&quot;5&quot;, VK_5}, {&quot;6&quot;, VK_6}, {&quot;7&quot;, VK_7}, {&quot;8&quot;, VK_8}, {&quot;9&quot;, VK_9},&#10;            {&quot;a&quot;, VK_A}, {&quot;b&quot;, VK_B}, {&quot;c&quot;, VK_C}, {&quot;d&quot;, VK_D}, {&quot;e&quot;, VK_E},&#10;            {&quot;f&quot;, VK_F}, {&quot;g&quot;, VK_G}, {&quot;h&quot;, VK_H}, {&quot;i&quot;, VK_I}, {&quot;j&quot;, VK_J},&#10;            {&quot;k&quot;, VK_K}, {&quot;l&quot;, VK_L}, {&quot;m&quot;, VK_M}, {&quot;n&quot;, VK_N}, {&quot;o&quot;, VK_O},&#10;            {&quot;p&quot;, VK_P}, {&quot;q&quot;, VK_Q}, {&quot;r&quot;, VK_R}, {&quot;s&quot;, VK_S}, {&quot;t&quot;, VK_T},&#10;            {&quot;u&quot;, VK_U}, {&quot;v&quot;, VK_V}, {&quot;w&quot;, VK_W}, {&quot;x&quot;, VK_X}, {&quot;y&quot;, VK_Y},&#10;            {&quot;z&quot;, VK_Z}&#10;        };&#10;        std::string key = str;&#10;        std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) { return std::tolower(c); });&#10;        if (key.length() &gt; 3 &amp;&amp; key.substr(0, 3) == &quot;vk_&quot;) key = key.substr(3);&#10;        if (const auto item = vkMap.find(key); item != vkMap.end()) return item-&gt;second;&#10;        return VK_H;&#10;    }&#10;&#10;    void ClampAll() {&#10;        horizontal.Clamp();&#10;        vertical.Clamp();&#10;        hotkey.Clamp();&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.cpp" />
              <option name="originalContent" value="#include &quot;config_file_util.h&quot;&#10;#include &lt;windows.h&gt;&#10;#include &lt;fstream&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path() {&#10;    char exePath[MAX_PATH] = {};&#10;    GetModuleFileNameA(nullptr, exePath, MAX_PATH);&#10;    std::string path(exePath);&#10;    if (const size_t pos = path.find_last_of(&quot;\\/&quot;); pos != std::string::npos) {&#10;        path = path.substr(0, pos + 1);&#10;    } else {&#10;        path = &quot;./&quot;;&#10;    }&#10;    return path + &quot;crosshair.ini&quot;;&#10;}&#10;&#10;// 写入默认配置内容&#10;static void write_default_config(const std::string &amp;path) {&#10;    std::ofstream ofs(path, std::ios::out | std::ios::trunc);&#10;    ofs &lt;&lt; DEFAULT_INI;&#10;    ofs.close();&#10;}&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string &amp;path) {&#10;    const DWORD attr = GetFileAttributesA(path.c_str());&#10;    if (attr == INVALID_FILE_ATTRIBUTES || attr &amp; FILE_ATTRIBUTE_DIRECTORY) {&#10;        write_default_config(path);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;config_file_util.h&quot;&#13;&#10;#include &lt;windows.h&gt;&#13;&#10;#include &lt;fstream&gt;&#13;&#10;&#13;&#10;// 获取配置文件绝对路径（与exe同目录）&#13;&#10;std::string get_config_path() {&#13;&#10;    char path[MAX_PATH];&#13;&#10;    GetModuleFileNameA(nullptr, path, MAX_PATH);&#13;&#10;    std::string exePath = path;&#13;&#10;    size_t pos = exePath.find_last_of(&quot;\\/&quot;);&#13;&#10;    if (pos != std::string::npos) {&#13;&#10;        exePath = exePath.substr(0, pos + 1);&#13;&#10;    }&#13;&#10;    return exePath + &quot;config.ini&quot;;&#13;&#10;}&#13;&#10;&#13;&#10;// 如果配置文件不存在则创建&#13;&#10;void ensure_config_exists(const std::string &amp;path) {&#13;&#10;    std::ifstream file(path);&#13;&#10;    if (!file.good()) {&#13;&#10;        std::ofstream outFile(path);&#13;&#10;        if (outFile.is_open()) {&#13;&#10;            outFile &lt;&lt; DEFAULT_INI;&#13;&#10;            outFile.close();&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config_file_util.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config_file_util.h" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;string&gt;&#10;&#10;// 获取配置文件绝对路径（与exe同目录）&#10;std::string get_config_path();&#10;&#10;// 如果配置文件不存在则创建&#10;void ensure_config_exists(const std::string&amp; path);&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.cpp" />
              <option name="originalContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 16&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 使用FALSE避免背景擦除&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha的DIB&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int left = std::max(0, pt.x - halfLength);&#10;        int right = std::min(width, pt.x + halfLength);&#10;&#10;        if (left &lt; right) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(left),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;                static_cast&lt;Gdiplus::REAL&gt;(right),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;            );&#10;        }&#10;    }&#10;&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int top = std::max(0, pt.y - halfLength);&#10;        int bottom = std::min(height, pt.y + halfLength);&#10;&#10;        if (top &lt; bottom) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(top),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(bottom)&#10;            );&#10;        }&#10;    }&#10;&#10;    POINT ptSrc = { 0, 0 };&#10;    SIZE sizeWnd = { width, height };&#10;    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;crosshair.h&quot;&#10;#include &lt;gdiplus.h&gt;&#10;#include &lt;algorithm&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#define CLASS_NAME L&quot;MouseCrosshairWindow&quot;&#10;#define TIMER_ID 0x1001&#10;#define TIMER_INTERVAL 16&#10;&#10;CrosshairWindow::CrosshairWindow(const HINSTANCE hInst, const Config &amp;cfg)&#10;    : hInstance(hInst), hwnd(nullptr), config(cfg), visible(true) {&#10;}&#10;&#10;CrosshairWindow::~CrosshairWindow() {&#10;    if (hwnd) {&#10;        KillTimer(hwnd, TIMER_ID);&#10;        DestroyWindow(hwnd);&#10;    }&#10;}&#10;&#10;bool CrosshairWindow::Create() {&#10;    WNDCLASSEXW wc = {sizeof(wc)};&#10;    wc.lpfnWndProc = WndProc;&#10;    wc.hInstance = hInstance;&#10;    wc.lpszClassName = CLASS_NAME;&#10;    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);&#10;    wc.hbrBackground = nullptr;&#10;    wc.style = CS_HREDRAW | CS_VREDRAW;&#10;&#10;    RegisterClassExW(&amp;wc);&#10;&#10;    hwnd = CreateWindowExW(&#10;        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_TOOLWINDOW,&#10;        CLASS_NAME, L&quot;&quot;, WS_POPUP,&#10;        0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN),&#10;        nullptr, nullptr, hInstance, this);&#10;&#10;    if (!hwnd) return false;&#10;&#10;    SetTimer(hwnd, TIMER_ID, TIMER_INTERVAL, nullptr);&#10;    ShowWindow(hwnd, SW_SHOW);&#10;    return true;&#10;}&#10;&#10;void CrosshairWindow::ToggleVisible() {&#10;    visible = !visible;&#10;    ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);&#10;}&#10;&#10;LRESULT CALLBACK CrosshairWindow::WndProc(const HWND hWnd, const UINT msg, WPARAM wParam, LPARAM lParam) {&#10;    CrosshairWindow *self = nullptr;&#10;    if (msg == WM_NCCREATE) {&#10;        const CREATESTRUCT *cs = reinterpret_cast&lt;CREATESTRUCT *&gt;(lParam);&#10;        self = static_cast&lt;CrosshairWindow *&gt;(cs-&gt;lpCreateParams);&#10;        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast&lt;LONG_PTR&gt;(self));&#10;        self-&gt;hwnd = hWnd;&#10;    } else {&#10;        self = reinterpret_cast&lt;CrosshairWindow *&gt;(GetWindowLongPtr(hWnd, GWLP_USERDATA));&#10;    }&#10;&#10;    switch (msg) {&#10;        case WM_PAINT:&#10;            if (self) {&#10;                PAINTSTRUCT ps;&#10;                const HDC hdc = BeginPaint(hWnd, &amp;ps);&#10;                self-&gt;DrawCrosshair(hdc);&#10;                EndPaint(hWnd, &amp;ps);&#10;            }&#10;            return 0;&#10;        case WM_ERASEBKGND:&#10;            return 1; // 阻止背景擦除&#10;        case WM_TIMER:&#10;            if (wParam == TIMER_ID &amp;&amp; self &amp;&amp; self-&gt;visible) {&#10;                InvalidateRect(hWnd, nullptr, FALSE); // 使用FALSE避免背景擦除&#10;            }&#10;            return 0;&#10;        case WM_DESTROY:&#10;            KillTimer(hWnd, TIMER_ID);&#10;            PostQuitMessage(0);&#10;            return 0;&#10;        default:&#10;            return DefWindowProc(hWnd, msg, wParam, lParam);&#10;    }&#10;}&#10;&#10;&#10;void CrosshairWindow::DrawCrosshair(const HDC hdc) const {&#10;    RECT rc;&#10;    GetClientRect(hwnd, &amp;rc);&#10;    const int width = rc.right - rc.left;&#10;    const int height = rc.bottom - rc.top;&#10;&#10;    // 创建32位带alpha的DIB&#10;    BITMAPINFO bmi = {};&#10;    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);&#10;    bmi.bmiHeader.biWidth = width;&#10;    bmi.bmiHeader.biHeight = -height; // top-down&#10;    bmi.bmiHeader.biPlanes = 1;&#10;    bmi.bmiHeader.biBitCount = 32;&#10;    bmi.bmiHeader.biCompression = BI_RGB;&#10;&#10;    void *bits = nullptr;&#10;    HDC screenDC = GetDC(nullptr);&#10;    HBITMAP hBmp = CreateDIBSection(screenDC, &amp;bmi, DIB_RGB_COLORS, &amp;bits, nullptr, 0);&#10;    HDC memDC = CreateCompatibleDC(screenDC);&#10;    HGDIOBJ oldBmp = SelectObject(memDC, hBmp);&#10;&#10;    Gdiplus::Graphics graphics(memDC);&#10;    graphics.Clear(Gdiplus::Color(0, 0, 0, 0));&#10;    graphics.SetSmoothingMode(Gdiplus::SmoothingModeAntiAlias);&#10;&#10;    POINT pt;&#10;    GetCursorPos(&amp;pt);&#10;    ScreenToClient(hwnd, &amp;pt);&#10;&#10;    // 横线&#10;    {&#10;        const auto &amp;c = config.horizontal;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int left = std::max(0, pt.x - halfLength);&#10;        int right = std::min(width, pt.x + halfLength);&#10;&#10;        if (left &lt; right) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(left),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y),&#10;                static_cast&lt;Gdiplus::REAL&gt;(right),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.y)&#10;            );&#10;        }&#10;    }&#10;&#10;    // 竖线&#10;    {&#10;        const auto &amp;c = config.vertical;&#10;        Gdiplus::Pen pen(&#10;            Gdiplus::Color(c.alpha, c.r, c.g, c.b),&#10;            static_cast&lt;Gdiplus::REAL&gt;(c.width)&#10;        );&#10;&#10;        int halfLength = static_cast&lt;int&gt;(c.length) / 2;&#10;        int top = std::max(0, pt.y - halfLength);&#10;        int bottom = std::min(height, pt.y + halfLength);&#10;&#10;        if (top &lt; bottom) {&#10;            graphics.DrawLine(&#10;                &amp;pen,&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(top),&#10;                static_cast&lt;Gdiplus::REAL&gt;(pt.x),&#10;                static_cast&lt;Gdiplus::REAL&gt;(bottom)&#10;            );&#10;        }&#10;    }&#10;&#10;    POINT ptSrc = { 0, 0 };&#10;    SIZE sizeWnd = { width, height };&#10;    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };&#10;    UpdateLayeredWindow(hwnd, screenDC, nullptr, &amp;sizeWnd, memDC, &amp;ptSrc, 0, &amp;blend, ULW_ALPHA);&#10;&#10;    SelectObject(memDC, oldBmp);&#10;    DeleteObject(hBmp);&#10;    DeleteDC(memDC);&#10;    ReleaseDC(nullptr, screenDC);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.h" />
              <option name="originalContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class CrosshairWindow {&#10;public:&#10;    CrosshairWindow(HINSTANCE hInst, const Config &amp;cfg);&#10;    ~CrosshairWindow();&#10;&#10;    bool Create();&#10;&#10;    void ToggleVisible();&#10;&#10;private:&#10;    static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);&#10;&#10;    void DrawCrosshair(HDC hdc) const;&#10;&#10;    HINSTANCE hInstance;&#10;    HWND hwnd;&#10;    Config config;&#10;    bool visible;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/crosshair.ini">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/crosshair.ini" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="[Horizontal]&#10;Length=60&#10;Width=3&#10;R=0&#10;G=255&#10;B=0&#10;Alpha=180&#10;&#10;[Vertical]&#10;Length=80&#10;Width=2&#10;R=255&#10;G=0&#10;B=0&#10;Alpha=200&#10;&#10;[Hotkey]&#10;; Mod为修饰键位掩码，见WinAPI RegisterHotKey文档&#10;; 1=Alt, 2=Ctrl, 4=Shift, 8=Win，可组合&#10;Mod=3&#10;; VK可为单字母（如H），或虚拟键码（如0x70为F1）&#10;VK=H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.cpp" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#include &quot;hotkey.h&quot;&#10;&#10;#define HOTKEY_ID 0x1234&#10;&#10;void HotkeyManager::RegisterToggleHotkey(const HotkeyConfig&amp; cfg) {&#10;    RegisterHotKey(nullptr, HOTKEY_ID, cfg.mod, cfg.vk);&#10;}&#10;&#10;bool HotkeyManager::IsToggleHotkey(const MSG&amp; msg) {&#10;    return msg.message == WM_HOTKEY &amp;&amp; msg.wParam == HOTKEY_ID;&#10;}&#10;&#10;void HotkeyManager::UnregisterAll() {&#10;    UnregisterHotKey(nullptr, HOTKEY_ID);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hotkey.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hotkey.h" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;windows.h&gt;&#10;#include &quot;config.h&quot;&#10;&#10;class HotkeyManager {&#10;public:&#10;    void RegisterToggleHotkey(const HotkeyConfig&amp; cfg);&#10;    bool IsToggleHotkey(const MSG&amp; msg);&#10;    void UnregisterAll();&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.cpp" />
              <option name="originalContent" value="#include &lt;windows.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#include &quot;crosshair.h&quot;&#10;#include &quot;config.h&quot;&#10;#include &quot;hotkey.h&quot;&#10;#include &quot;config_file_util.h&quot;&#10;&#10;using namespace Gdiplus;&#10;&#10;ULONG_PTR gdiToken;&#10;&#10;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int) {&#10;    GdiplusStartupInput gdiplusStartupInput;&#10;    GdiplusStartup(&amp;gdiToken, &amp;gdiplusStartupInput, nullptr);&#10;&#10;    const std::string configPath = get_config_path();&#10;    ensure_config_exists(configPath);&#10;&#10;    Config config;&#10;    if (!config.Load(configPath.c_str())) {&#10;        MessageBoxA(nullptr, &quot;Error load config, use default values.&quot;, &quot;Warning&quot;, MB_OK | MB_ICONINFORMATION);&#10;    }&#10;    config.AutoSetLength();&#10;&#10;    CrosshairWindow crosshair(hInstance, config);&#10;    if (!crosshair.Create()) {&#10;        MessageBoxA(nullptr, &quot;Error creating Crosshair window.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        GdiplusShutdown(gdiToken);&#10;        return 1;&#10;    }&#10;&#10;    HotkeyManager hotkey;&#10;    hotkey.RegisterToggleHotkey(config.hotkey);&#10;&#10;    MSG msg;&#10;    while (GetMessage(&amp;msg, nullptr, 0, 0)) {&#10;        if (hotkey.IsToggleHotkey(msg)) {&#10;            crosshair.ToggleVisible();&#10;            continue;&#10;        }&#10;        TranslateMessage(&amp;msg);&#10;        DispatchMessage(&amp;msg);&#10;    }&#10;&#10;    GdiplusShutdown(gdiToken);&#10;    hotkey.UnregisterAll();&#10;    return 0;&#10;}" />
              <option name="updatedContent" value="#include &lt;windows.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;gdiplus.h&gt;&#10;#pragma comment(lib, &quot;gdiplus.lib&quot;)&#10;&#10;#include &quot;crosshair.h&quot;&#10;#include &quot;config.h&quot;&#10;#include &quot;hotkey.h&quot;&#10;#include &quot;config_file_util.h&quot;&#10;&#10;using namespace Gdiplus;&#10;&#10;ULONG_PTR gdiToken;&#10;&#10;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int) {&#10;    // 在程序开始时设置DPI感知&#10;    SetProcessDPIAware();&#10;    &#10;    GdiplusStartupInput gdiplusStartupInput;&#10;    GdiplusStartup(&amp;gdiToken, &amp;gdiplusStartupInput, nullptr);&#10;&#10;    const std::string configPath = get_config_path();&#10;    ensure_config_exists(configPath);&#10;&#10;    Config config;&#10;    if (!config.Load(configPath.c_str())) {&#10;        MessageBoxA(nullptr, &quot;Error load config, use default values.&quot;, &quot;Warning&quot;, MB_OK | MB_ICONINFORMATION);&#10;    }&#10;    config.AutoSetLength();&#10;&#10;    CrosshairWindow crosshair(hInstance, config);&#10;    if (!crosshair.Create()) {&#10;        MessageBoxA(nullptr, &quot;Error creating Crosshair window.&quot;, &quot;Error&quot;, MB_OK | MB_ICONERROR);&#10;        GdiplusShutdown(gdiToken);&#10;        return 1;&#10;    }&#10;&#10;    HotkeyManager hotkey;&#10;    hotkey.RegisterToggleHotkey(config.hotkey);&#10;&#10;    MSG msg;&#10;    while (GetMessage(&amp;msg, nullptr, 0, 0)) {&#10;        if (hotkey.IsToggleHotkey(msg)) {&#10;            crosshair.ToggleVisible();&#10;            continue;&#10;        }&#10;        TranslateMessage(&amp;msg);&#10;        DispatchMessage(&amp;msg);&#10;    }&#10;&#10;    hotkey.UnregisterAll();&#10;    GdiplusShutdown(gdiToken);&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>